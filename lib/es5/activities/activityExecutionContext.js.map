{"version":3,"names":[],"mappings":"","sources":["activities/activityExecutionContext.js"],"sourcesContent":["\"use strict\";\r\n\r\nlet ActivityExecutionState = require(\"./activityExecutionState\");\r\nlet ResumeBookmarkQueue = require(\"./resumeBookmarkQueue\");\r\nlet enums = require(\"../common/enums\");\r\nlet errors = require(\"../common/errors\");\r\nlet util = require(\"util\");\r\nlet EventEmitter = require(\"events\").EventEmitter;\r\nlet _ = require(\"lodash\");\r\nlet constants = require(\"../common/constants\");\r\nlet ScopeTree = require(\"./scopeTree\");\r\nlet is = require(\"../common/is\");\r\nlet CallContext = require(\"./callContext\");\r\nlet assert = require(\"better-assert\");\r\nlet Bluebird = require(\"bluebird\");\r\nlet converters = require(\"../common/converters\");\r\n\r\nfunction ActivityExecutionContext(engine) {\r\n    EventEmitter.call(this);\r\n\r\n    this._activityStates = new Map();\r\n    this._bookmarks = new Map();\r\n    this._resumeBMQueue = new ResumeBookmarkQueue();\r\n    this.rootActivity = null;\r\n    this._knownActivities = new Map();\r\n    this._scopeTree = this._createScopeTree();\r\n    this.engine = engine; // Could be null in special cases, see workflowRegistry.js\r\n}\r\n\r\nutil.inherits(ActivityExecutionContext, EventEmitter);\r\n\r\nObject.defineProperties(\r\n    ActivityExecutionContext.prototype,\r\n    {\r\n        scope: {\r\n            get: function () {\r\n                return this._scopeTree.currentScope;\r\n            }\r\n        },\r\n        hasScope: {\r\n            get: function () {\r\n                return !this._scopeTree.isOnInitial;\r\n            }\r\n        }\r\n    }\r\n);\r\n\r\nActivityExecutionContext.prototype._createScopeTree = function () {\r\n    let self = this;\r\n    return new ScopeTree(\r\n        {\r\n            resultCollected: function (context, reason, result, bookmarkName) {\r\n                context.activity.resultCollected.call(context.scope, context, reason, result, bookmarkName);\r\n            }\r\n        },\r\n        function (id) {\r\n            return self._getKnownActivity(id);\r\n        });\r\n};\r\n\r\nActivityExecutionContext.prototype.initialize = function (rootActivity) {\r\n    if (this.rootActivity) {\r\n        throw new Error(\"Context is already initialized.\");\r\n    }\r\n    if (!is.activity(rootActivity)) {\r\n        throw new TypeError(\"Argument 'rootActivity' value is not an activity.\");\r\n    }\r\n\r\n    this.rootActivity = rootActivity;\r\n    this._initialize(null, rootActivity, { instanceId: 0 });\r\n};\r\n\r\nActivityExecutionContext.prototype._checkInit = function () {\r\n    if (!this.rootActivity) {\r\n        throw new Error(\"Context is not initialized.\");\r\n    }\r\n};\r\n\r\nActivityExecutionContext.prototype._initialize = function (parent, activity, idCounter) {\r\n    let activityId = activity._instanceId;\r\n    let nextId = (idCounter.instanceId++).toString();\r\n    if (!activityId) {\r\n        activityId = nextId;\r\n        activity.instanceId = activityId;\r\n    }\r\n    else if (activityId !== nextId) {\r\n        throw new errors.ActivityRuntimeError(\"Activity \" + activity + \" has been assigned to an other position.\");\r\n    }\r\n\r\n    let state = this.getExecutionState(activityId);\r\n    state.parentInstanceId = parent ? parent.instanceId : null;\r\n    this._knownActivities.set(activityId, activity);\r\n\r\n    for (let child of activity.immediateChildren(this)) {\r\n        this._initialize(activity, child, idCounter);\r\n        state.childInstanceIds.add(child.instanceId);\r\n    }\r\n};\r\n\r\nActivityExecutionContext.prototype.getExecutionState = function (idOrActivity) {\r\n    let self = this;\r\n\r\n    let id;\r\n    if (_.isString(idOrActivity)) {\r\n        id = idOrActivity;\r\n    }\r\n    else if (is.activity(idOrActivity)) {\r\n        id = idOrActivity.instanceId;\r\n    }\r\n    else {\r\n        throw new TypeError(\"Cannot get state of \" + idOrActivity);\r\n    }\r\n    let state = self._activityStates.get(id);\r\n    if (_.isUndefined(state)) {\r\n        state = new ActivityExecutionState(id);\r\n        state.on(\r\n            enums.activityStates.run,\r\n            function (args) {\r\n                self.emit(enums.activityStates.run, args);\r\n            });\r\n        state.on(\r\n            enums.activityStates.end,\r\n            function (args) {\r\n                self.emit(enums.activityStates.end, args);\r\n            });\r\n        self._activityStates.set(id, state);\r\n    }\r\n    return state;\r\n};\r\n\r\nActivityExecutionContext.prototype._getKnownActivity = function (activityId) {\r\n    let activity = this._knownActivities.get(activityId);\r\n    if (!activity) {\r\n        throw new errors.ActivityRuntimeError(\"Activity by id '\" + activityId + \"' not found.\");\r\n    }\r\n    return activity;\r\n};\r\n\r\nActivityExecutionContext.prototype.createBookmark = function (activityId, name, endCallback) {\r\n    this.registerBookmark(\r\n        {\r\n            name: name,\r\n            instanceId: activityId,\r\n            timestamp: new Date().getTime(),\r\n            endCallback: endCallback\r\n        });\r\n    return name;\r\n};\r\n\r\nActivityExecutionContext.prototype.registerBookmark = function (bookmark) {\r\n    let bm = this._bookmarks.get(bookmark.name);\r\n    if (bm) {\r\n        throw new errors.ActivityRuntimeError(\"Bookmark '\" + bookmark.name + \"' already exists.\");\r\n    }\r\n    this._bookmarks.set(bookmark.name, bookmark);\r\n};\r\n\r\nActivityExecutionContext.prototype.isBookmarkExists = function (name) {\r\n    return this._bookmarks.has(name);\r\n};\r\n\r\nActivityExecutionContext.prototype.getBookmarkTimestamp = function (name, throwIfNotFound) {\r\n    let bm = this._bookmarks.get(name);\r\n    if (_.isUndefined(bm) && throwIfNotFound) {\r\n        throw new Error(\"Bookmark '\" + name + \"' not found.\");\r\n    }\r\n    return bm ? bm.timestamp : null;\r\n};\r\n\r\nActivityExecutionContext.prototype.deleteBookmark = function (name) {\r\n    this._bookmarks.delete(name);\r\n};\r\n\r\nActivityExecutionContext.prototype.noopCallbacks = function (bookmarkNames) {\r\n    for (let name of bookmarkNames) {\r\n        let bm = this._bookmarks.get(name);\r\n        if (bm) {\r\n            bm.endCallback = _.noop;\r\n        }\r\n    }\r\n};\r\n\r\nActivityExecutionContext.prototype.resumeBookmarkInScope = function (callContext, name, reason, result) {\r\n    let bm = this._bookmarks.get(name);\r\n    if (_.isUndefined(bm)) {\r\n        throw new Error(\"Bookmark '\" + name + \"' doesn't exists. Cannot continue with reason: \" + reason + \".\");\r\n    }\r\n    let self = this;\r\n    return new Bluebird(function (resolve, reject) {\r\n        setImmediate(function () {\r\n            try {\r\n                bm = self._bookmarks.get(name);\r\n                if (bm) {\r\n                    // If bm is still exists.\r\n                    self._doResumeBookmark(callContext, bm, reason, result, reason === enums.activityStates.idle);\r\n                    resolve(true);\r\n                }\r\n                resolve(false);\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\nActivityExecutionContext.prototype.resumeBookmarkInternal = function (callContext, name, reason, result) {\r\n    let bm = this._bookmarks.get(name);\r\n    this._resumeBMQueue.enqueue(name, reason, result);\r\n};\r\n\r\nActivityExecutionContext.prototype.resumeBookmarkExternal = function (name, reason, result) {\r\n    let self = this;\r\n    let bm = self._bookmarks.get(name);\r\n    if (!bm) {\r\n        throw new errors.BookmarkNotFoundError(\"Internal resume bookmark request cannot be processed because bookmark '\" + name + \"' doesn't exists.\");\r\n    }\r\n    self._doResumeBookmark(new CallContext(this, bm.instanceId), bm, reason, result);\r\n};\r\n\r\nActivityExecutionContext.prototype.processResumeBookmarkQueue = function () {\r\n    let self = this;\r\n    let command = self._resumeBMQueue.dequeue();\r\n    if (command) {\r\n        let bm = self._bookmarks.get(command.name);\r\n        if (!bm) {\r\n            throw new errors.BookmarkNotFoundError(\"Internal resume bookmark request cannot be processed because bookmark '\" + command.name + \"' doesn't exists.\");\r\n        }\r\n        self._doResumeBookmark(new CallContext(this, bm.instanceId), bm, command.reason, command.result);\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nActivityExecutionContext.prototype._doResumeBookmark = function (callContext, bookmark, reason, result, noRemove) {\r\n    let scope = callContext.scope;\r\n    if (!noRemove) {\r\n        this._bookmarks.delete(bookmark.name);\r\n    }\r\n    let cb = bookmark.endCallback;\r\n    if (_.isString(cb)) {\r\n        cb = scope[bookmark.endCallback];\r\n        if (!_.isFunction(cb)) {\r\n            cb = null;\r\n        }\r\n    }\r\n\r\n    if (!cb) {\r\n        throw new errors.ActivityRuntimeError(\"Bookmark's '\" + bookmark.name + \"' callback '\" + bookmark.endCallback + \"' is not defined on the current scope.\");\r\n    }\r\n\r\n    // TODO: if it fails, resume on default callback with the error!\r\n    cb.call(scope, callContext, reason, result, bookmark);\r\n};\r\n\r\nActivityExecutionContext.prototype.cancelExecution = function (scope, activityIds) {\r\n    let self = this;\r\n    let allIds = new Set();\r\n    for (let id of activityIds) {\r\n        self._cancelSubtree(scope, allIds, id);\r\n    }\r\n    for (let bm of self._bookmarks.values()) {\r\n        if (allIds.has(bm.instanceId)) {\r\n            self._bookmarks.delete(bm.name);\r\n        }\r\n    }\r\n};\r\n\r\nActivityExecutionContext.prototype._cancelSubtree = function (scope, allIds, activityId) {\r\n    let self = this;\r\n    allIds.add(activityId);\r\n    let state = self.getExecutionState(activityId);\r\n    for (let id of state.childInstanceIds.values()) {\r\n        self._cancelSubtree(scope, allIds, id);\r\n    }\r\n    state.reportState(enums.activityStates.cancel, null, scope);\r\n};\r\n\r\nActivityExecutionContext.prototype.deleteScopeOfActivity = function (callContext, activityId) {\r\n    this._scopeTree.deleteScopePart(callContext.instanceId, activityId);\r\n};\r\n\r\nActivityExecutionContext.prototype.emitWorkflowEvent = function (args) {\r\n    this.emit(enums.events.workflowEvent, args);\r\n};\r\n\r\n/* SERIALIZATION */\r\n\r\nActivityExecutionContext.prototype.getStateAndPromotions = function (serializer, enablePromotions) {\r\n    if (serializer && !_.isFunction(serializer.toJSON)) {\r\n        throw new TypeError(\"Argument 'serializer' is not a serializer.\");\r\n    }\r\n\r\n    let activityStates = new Map();\r\n    for (let s of this._activityStates.values()) {\r\n        activityStates.set(s.instanceId, s.asJSON());\r\n    }\r\n\r\n    let scopeStateAndPromotions = this._scopeTree.getExecutionState(this, enablePromotions, serializer);\r\n\r\n    let serialized;\r\n    if (serializer) {\r\n        serialized = serializer.toJSON({\r\n            activityStates: activityStates,\r\n            bookmarks: this._bookmarks,\r\n            scope: scopeStateAndPromotions.state\r\n        });\r\n    }\r\n    else {\r\n        serialized = {\r\n            activityStates: converters.mapToArray(activityStates),\r\n            bookmarks: converters.mapToArray(this._bookmarks),\r\n            scope: scopeStateAndPromotions.state\r\n        };\r\n    }\r\n\r\n    return {\r\n        state: serialized,\r\n        promotedProperties: scopeStateAndPromotions.promotedProperties\r\n    };\r\n};\r\n\r\nActivityExecutionContext.prototype.setState = function (serializer, json) {\r\n    if (serializer && !_.isFunction(serializer.fromJSON)) {\r\n        throw new TypeError(\"Argument 'serializer' is not a serializer.\");\r\n    }\r\n    if (!_.isObject(json)) {\r\n        throw new TypeError(\"Argument 'json' is not an object.\");\r\n    }\r\n\r\n    if (serializer) {\r\n        json = serializer.fromJSON(json);\r\n        if (!(json.activityStates instanceof Map)) {\r\n            throw new TypeError(\"activityStates property value of argument 'json' is not an Map instance.\");\r\n        }\r\n        if (!(json.bookmarks instanceof Map)) {\r\n            throw new TypeError(\"Bookmarks property value of argument 'json' is not an Map instance.\");\r\n        }\r\n    }\r\n    else {\r\n        if (!json.activityStates) {\r\n            throw new TypeError(\"activityStates property value of argument 'json' is not an object.\");\r\n        }\r\n        if (!json.bookmarks) {\r\n            throw new TypeError(\"Bookmarks property value of argument 'json' is not an object.\");\r\n        }\r\n\r\n        json = {\r\n            activityStates: converters.arrayToMap(json.activityStates),\r\n            bookmarks: converters.arrayToMap(json.bookmarks),\r\n            scope: json.scope\r\n        };\r\n    }\r\n\r\n    for (let s of this._activityStates.values()) {\r\n        let stored = json.activityStates.get(s.instanceId);\r\n        if (_.isUndefined(stored)) {\r\n            throw new Error(\"Activity's of '\" + s.instanceId + \"' state not found.\");\r\n        }\r\n        s.fromJSON(stored);\r\n    }\r\n\r\n    this._bookmarks = json.bookmarks;\r\n    this._scopeTree.setState(json.scope, serializer);\r\n};\r\n/* SERIALIZATION */\r\n\r\nmodule.exports = ActivityExecutionContext;"],"file":"activities/activityExecutionContext.js","sourceRoot":"/source/"}