{"version":3,"names":[],"mappings":"","sources":["activities/activityExecutionContext.js"],"sourcesContent":["\"use strict\";\n\nlet ActivityExecutionState = require(\"./activityExecutionState\");\nlet ResumeBookmarkQueue = require(\"./resumeBookmarkQueue\");\nlet enums = require(\"../common/enums\");\nlet errors = require(\"../common/errors\");\nlet util = require(\"util\");\nlet EventEmitter = require(\"events\").EventEmitter;\nlet _ = require(\"lodash\");\nlet constants = require(\"../common/constants\");\nlet ScopeTree = require(\"./scopeTree\");\nlet is = require(\"../common/is\");\nlet CallContext = require(\"./callContext\");\nlet assert = require(\"better-assert\");\nlet Bluebird = require(\"bluebird\");\nlet converters = require(\"../common/converters\");\n\nfunction ActivityExecutionContext(engine) {\n    EventEmitter.call(this);\n\n    this._activityStates = new Map();\n    this._bookmarks = new Map();\n    this._resumeBMQueue = new ResumeBookmarkQueue();\n    this.rootActivity = null;\n    this._knownActivities = new Map();\n    this._scopeTree = this._createScopeTree();\n    this.engine = engine; // Could be null in special cases, see workflowRegistry.js\n}\n\nutil.inherits(ActivityExecutionContext, EventEmitter);\n\nObject.defineProperties(\n    ActivityExecutionContext.prototype,\n    {\n        scope: {\n            get: function () {\n                return this._scopeTree.currentScope;\n            }\n        },\n        hasScope: {\n            get: function () {\n                return !this._scopeTree.isOnInitial;\n            }\n        }\n    }\n);\n\nActivityExecutionContext.prototype._createScopeTree = function () {\n    let self = this;\n    return new ScopeTree(\n        {\n            resultCollected: function (context, reason, result, bookmarkName) {\n                context.activity.resultCollected.call(context.scope, context, reason, result, bookmarkName);\n            }\n        },\n        function (id) {\n            return self._getKnownActivity(id);\n        });\n};\n\nActivityExecutionContext.prototype.initialize = function (rootActivity) {\n    if (this.rootActivity) {\n        throw new Error(\"Context is already initialized.\");\n    }\n    if (!is.activity(rootActivity)) {\n        throw new TypeError(\"Argument 'rootActivity' value is not an activity.\");\n    }\n\n    this.rootActivity = rootActivity;\n    this._initialize(null, rootActivity, { instanceId: 0 });\n};\n\nActivityExecutionContext.prototype._checkInit = function () {\n    if (!this.rootActivity) {\n        throw new Error(\"Context is not initialized.\");\n    }\n};\n\nActivityExecutionContext.prototype._initialize = function (parent, activity, idCounter) {\n    let activityId = activity._instanceId;\n    let nextId = (idCounter.instanceId++).toString();\n    if (!activityId) {\n        activityId = nextId;\n        activity.instanceId = activityId;\n    }\n    else if (activityId !== nextId) {\n        throw new errors.ActivityRuntimeError(\"Activity \" + activity + \" has been assigned to an other position.\");\n    }\n\n    let state = this.getExecutionState(activityId);\n    state.parentInstanceId = parent ? parent.instanceId : null;\n    this._knownActivities.set(activityId, activity);\n\n    for (let child of activity.immediateChildren(this)) {\n        this._initialize(activity, child, idCounter);\n        state.childInstanceIds.add(child.instanceId);\n    }\n};\n\nActivityExecutionContext.prototype.getExecutionState = function (idOrActivity) {\n    let self = this;\n\n    let id;\n    if (_.isString(idOrActivity)) {\n        id = idOrActivity;\n    }\n    else if (is.activity(idOrActivity)) {\n        id = idOrActivity.instanceId;\n    }\n    else {\n        throw new TypeError(\"Cannot get state of \" + idOrActivity);\n    }\n    let state = self._activityStates.get(id);\n    if (_.isUndefined(state)) {\n        state = new ActivityExecutionState(id);\n        state.on(\n            enums.activityStates.run,\n            function (args) {\n                self.emit(enums.activityStates.run, args);\n            });\n        state.on(\n            enums.activityStates.end,\n            function (args) {\n                self.emit(enums.activityStates.end, args);\n            });\n        self._activityStates.set(id, state);\n    }\n    return state;\n};\n\nActivityExecutionContext.prototype._getKnownActivity = function (activityId) {\n    let activity = this._knownActivities.get(activityId);\n    if (!activity) {\n        throw new errors.ActivityRuntimeError(\"Activity by id '\" + activityId + \"' not found.\");\n    }\n    return activity;\n};\n\nActivityExecutionContext.prototype.createBookmark = function (activityId, name, endCallback) {\n    this.registerBookmark(\n        {\n            name: name,\n            instanceId: activityId,\n            timestamp: new Date().getTime(),\n            endCallback: endCallback\n        });\n    return name;\n};\n\nActivityExecutionContext.prototype.registerBookmark = function (bookmark) {\n    let bm = this._bookmarks.get(bookmark.name);\n    if (bm) {\n        throw new errors.ActivityRuntimeError(\"Bookmark '\" + bookmark.name + \"' already exists.\");\n    }\n    this._bookmarks.set(bookmark.name, bookmark);\n};\n\nActivityExecutionContext.prototype.isBookmarkExists = function (name) {\n    return this._bookmarks.has(name);\n};\n\nActivityExecutionContext.prototype.getBookmarkTimestamp = function (name, throwIfNotFound) {\n    let bm = this._bookmarks.get(name);\n    if (_.isUndefined(bm) && throwIfNotFound) {\n        throw new Error(\"Bookmark '\" + name + \"' not found.\");\n    }\n    return bm ? bm.timestamp : null;\n};\n\nActivityExecutionContext.prototype.deleteBookmark = function (name) {\n    this._bookmarks.delete(name);\n};\n\nActivityExecutionContext.prototype.noopCallbacks = function (bookmarkNames) {\n    for (let name of bookmarkNames) {\n        let bm = this._bookmarks.get(name);\n        if (bm) {\n            bm.endCallback = _.noop;\n        }\n    }\n};\n\nActivityExecutionContext.prototype.resumeBookmarkInScope = function (callContext, name, reason, result) {\n    let bm = this._bookmarks.get(name);\n    if (_.isUndefined(bm)) {\n        throw new Error(\"Bookmark '\" + name + \"' doesn't exists. Cannot continue with reason: \" + reason + \".\");\n    }\n    let self = this;\n    return new Bluebird(function (resolve, reject) {\n        setImmediate(function () {\n            try {\n                bm = self._bookmarks.get(name);\n                if (bm) {\n                    // If bm is still exists.\n                    self._doResumeBookmark(callContext, bm, reason, result, reason === enums.activityStates.idle);\n                    resolve(true);\n                }\n                resolve(false);\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    });\n};\n\nActivityExecutionContext.prototype.resumeBookmarkInternal = function (callContext, name, reason, result) {\n    let bm = this._bookmarks.get(name);\n    this._resumeBMQueue.enqueue(name, reason, result);\n};\n\nActivityExecutionContext.prototype.resumeBookmarkExternal = function (name, reason, result) {\n    let self = this;\n    let bm = self._bookmarks.get(name);\n    if (!bm) {\n        throw new errors.BookmarkNotFoundError(\"Internal resume bookmark request cannot be processed because bookmark '\" + name + \"' doesn't exists.\");\n    }\n    self._doResumeBookmark(new CallContext(this, bm.instanceId), bm, reason, result);\n};\n\nActivityExecutionContext.prototype.processResumeBookmarkQueue = function () {\n    let self = this;\n    let command = self._resumeBMQueue.dequeue();\n    if (command) {\n        let bm = self._bookmarks.get(command.name);\n        if (!bm) {\n            throw new errors.BookmarkNotFoundError(\"Internal resume bookmark request cannot be processed because bookmark '\" + command.name + \"' doesn't exists.\");\n        }\n        self._doResumeBookmark(new CallContext(this, bm.instanceId), bm, command.reason, command.result);\n        return true;\n    }\n    return false;\n};\n\nActivityExecutionContext.prototype._doResumeBookmark = function (callContext, bookmark, reason, result, noRemove) {\n    let scope = callContext.scope;\n    if (!noRemove) {\n        this._bookmarks.delete(bookmark.name);\n    }\n    let cb = bookmark.endCallback;\n    if (_.isString(cb)) {\n        cb = scope[bookmark.endCallback];\n        if (!_.isFunction(cb)) {\n            cb = null;\n        }\n    }\n\n    if (!cb) {\n        throw new errors.ActivityRuntimeError(\"Bookmark's '\" + bookmark.name + \"' callback '\" + bookmark.endCallback + \"' is not defined on the current scope.\");\n    }\n\n    cb.call(scope, callContext, reason, result, bookmark);\n};\n\nActivityExecutionContext.prototype.cancelExecution = function (scope, activityIds) {\n    let self = this;\n    let allIds = new Set();\n    for (let id of activityIds) {\n        self._cancelSubtree(scope, allIds, id);\n    }\n    for (let bm of self._bookmarks.values()) {\n        if (allIds.has(bm.instanceId)) {\n            self._bookmarks.delete(bm.name);\n        }\n    }\n};\n\nActivityExecutionContext.prototype._cancelSubtree = function (scope, allIds, activityId) {\n    let self = this;\n    allIds.add(activityId);\n    let state = self.getExecutionState(activityId);\n    for (let id of state.childInstanceIds.values()) {\n        self._cancelSubtree(scope, allIds, id);\n    }\n    state.reportState(enums.activityStates.cancel, null, scope);\n};\n\nActivityExecutionContext.prototype.deleteScopeOfActivity = function (callContext, activityId) {\n    this._scopeTree.deleteScopePart(callContext.instanceId, activityId);\n};\n\nActivityExecutionContext.prototype.emitWorkflowEvent = function (args) {\n    this.emit(enums.events.workflowEvent, args);\n};\n\n/* SERIALIZATION */\n\nActivityExecutionContext.prototype.getStateAndPromotions = function (serializer, enablePromotions) {\n    if (serializer && !_.isFunction(serializer.toJSON)) {\n        throw new TypeError(\"Argument 'serializer' is not a serializer.\");\n    }\n\n    let activityStates = new Map();\n    for (let s of this._activityStates.values()) {\n        activityStates.set(s.instanceId, s.asJSON());\n    }\n\n    let scopeStateAndPromotions = this._scopeTree.getExecutionState(this, enablePromotions, serializer);\n\n    let serialized;\n    if (serializer) {\n        serialized = serializer.toJSON({\n            activityStates: activityStates,\n            bookmarks: this._bookmarks,\n            scope: scopeStateAndPromotions.state\n        });\n    }\n    else {\n        serialized = {\n            activityStates: converters.mapToArray(activityStates),\n            bookmarks: converters.mapToArray(this._bookmarks),\n            scope: scopeStateAndPromotions.state\n        };\n    }\n\n    return {\n        state: serialized,\n        promotedProperties: scopeStateAndPromotions.promotedProperties\n    };\n};\n\nActivityExecutionContext.prototype.setState = function (serializer, json) {\n    if (serializer && !_.isFunction(serializer.fromJSON)) {\n        throw new TypeError(\"Argument 'serializer' is not a serializer.\");\n    }\n    if (!_.isObject(json)) {\n        throw new TypeError(\"Argument 'json' is not an object.\");\n    }\n\n    if (serializer) {\n        json = serializer.fromJSON(json);\n        if (!(json.activityStates instanceof Map)) {\n            throw new TypeError(\"activityStates property value of argument 'json' is not an Map instance.\");\n        }\n        if (!(json.bookmarks instanceof Map)) {\n            throw new TypeError(\"Bookmarks property value of argument 'json' is not an Map instance.\");\n        }\n    }\n    else {\n        if (!json.activityStates) {\n            throw new TypeError(\"activityStates property value of argument 'json' is not an object.\");\n        }\n        if (!json.bookmarks) {\n            throw new TypeError(\"Bookmarks property value of argument 'json' is not an object.\");\n        }\n\n        json = {\n            activityStates: converters.arrayToMap(json.activityStates),\n            bookmarks: converters.arrayToMap(json.bookmarks),\n            scope: json.scope\n        };\n    }\n\n    for (let s of this._activityStates.values()) {\n        let stored = json.activityStates.get(s.instanceId);\n        if (_.isUndefined(stored)) {\n            throw new Error(\"Activity's of '\" + s.instanceId + \"' state not found.\");\n        }\n        s.fromJSON(stored);\n    }\n\n    this._bookmarks = json.bookmarks;\n    this._scopeTree.setState(json.scope, serializer);\n};\n/* SERIALIZATION */\n\nmodule.exports = ActivityExecutionContext;"],"file":"activities/activityExecutionContext.js","sourceRoot":"/source/"}