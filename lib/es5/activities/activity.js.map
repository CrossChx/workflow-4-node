{"version":3,"names":[],"mappings":"","sources":["activities/activity.js"],"sourcesContent":["/*jshint -W054 */\r\n\r\n\"use strict\";\r\n\r\nlet constants = require(\"../common/constants\");\r\nlet errors = require(\"../common/errors\");\r\nlet enums = require(\"../common/enums\");\r\nlet _ = require(\"lodash\");\r\nlet specStrings = require(\"../common/specStrings\");\r\nlet util = require(\"util\");\r\nlet is = require(\"../common/is\");\r\nlet CallContext = require(\"./callContext\");\r\nlet uuid = require('node-uuid');\r\nlet async = require(\"../common/asyncHelpers\").async;\r\nlet assert = require(\"better-assert\");\r\nlet debug = require(\"debug\")(\"wf4node:Activity\");\r\nlet common = require(\"../common\");\r\nlet SimpleProxy = common.SimpleProxy;\r\n\r\nfunction Activity() {\r\n    this.args = null;\r\n    this.displayName = null;\r\n    this.id = uuid.v4();\r\n    this._instanceId = null;\r\n    this._structureInitialized = false;\r\n    this._scopeKeys = null;\r\n    this._createScopePartImpl = null;\r\n    this[\"@require\"] = null;\r\n\r\n    // Properties not serialized:\r\n    this.nonSerializedProperties = new Set();\r\n\r\n    // Properties are not going to copied in the scope:\r\n    this.nonScopedProperties = new Set();\r\n    this.nonScopedProperties.add(\"nonScopedProperties\");\r\n    this.nonScopedProperties.add(\"nonSerializedProperties\");\r\n    this.nonScopedProperties.add(\"arrayProperties\");\r\n    this.nonScopedProperties.add(\"activity\");\r\n    this.nonScopedProperties.add(\"id\");\r\n    this.nonScopedProperties.add(\"_instanceId\");\r\n    this.nonScopedProperties.add(\"args\");\r\n    this.nonScopedProperties.add(\"displayName\");\r\n    this.nonScopedProperties.add(\"complete\");\r\n    this.nonScopedProperties.add(\"cancel\");\r\n    this.nonScopedProperties.add(\"idle\");\r\n    this.nonScopedProperties.add(\"fail\");\r\n    this.nonScopedProperties.add(\"end\");\r\n    this.nonScopedProperties.add(\"schedule\");\r\n    this.nonScopedProperties.add(\"createBookmark\");\r\n    this.nonScopedProperties.add(\"resumeBookmark\");\r\n    this.nonScopedProperties.add(\"resultCollected\");\r\n    this.nonScopedProperties.add(\"codeProperties\");\r\n    this.nonScopedProperties.add(\"initializeStructure\");\r\n    this.nonScopedProperties.add(\"_initializeStructure\");\r\n    this.nonScopedProperties.add(\"_structureInitialized\");\r\n    this.nonScopedProperties.add(\"clone\");\r\n    this.nonScopedProperties.add(\"_scopeKeys\");\r\n    this.nonScopedProperties.add(\"_createScopePartImpl\");\r\n    this.nonScopedProperties.add(\"@require\");\r\n    this.nonScopedProperties.add(\"initializeExec\");\r\n    this.nonScopedProperties.add(\"unInitializeExec\");\r\n\r\n    this.codeProperties = new Set();\r\n    this.arrayProperties = new Set([\"args\"]);\r\n}\r\n\r\nObject.defineProperties(Activity.prototype, {\r\n    collectAll: {\r\n        value: true,\r\n        writable: false,\r\n        enumerable: false\r\n    },\r\n    instanceId: {\r\n        enumerable: false,\r\n        get: function() {\r\n            if (this._instanceId) {\r\n                return this._instanceId;\r\n            }\r\n            throw new errors.ActivityRuntimeError(\"Activity is not initialized in a context.\");\r\n        },\r\n        set: function(value) {\r\n            this._instanceId = value;\r\n        }\r\n    }\r\n});\r\n\r\nActivity.prototype.toString = function () {\r\n    return (this.displayName ? (this.displayName + \" \") : \"\") + \"(\" + this.constructor.name + \":\" + this.id + \")\";\r\n};\r\n\r\n/* forEach */\r\nActivity.prototype.all = function* (execContext) {\r\n    yield * this._children(true, null, execContext, null);\r\n};\r\n\r\nActivity.prototype.children = function* (execContext) {\r\n    yield * this._children(true, this, execContext, null);\r\n};\r\n\r\nActivity.prototype.immediateChildren = function* (execContext) {\r\n    yield * this._children(false, this, execContext);\r\n};\r\n\r\nActivity.prototype._children = function* (deep, except, execContext, visited) {\r\n    assert(execContext instanceof require(\"./activityExecutionContext\"), \"Cannot enumerate activities without an execution context.\");\r\n    visited = visited || new Set();\r\n    let self = this;\r\n    if (!visited.has(self)) {\r\n        visited.add(self);\r\n\r\n        // Ensure it's structure created:\r\n        this._initializeStructure(execContext);\r\n\r\n        if (self !== except) {\r\n            yield self;\r\n        }\r\n\r\n        for (let fieldName in self) {\r\n            if (self.hasOwnProperty(fieldName)) {\r\n                let fieldValue = self[fieldName];\r\n                if (fieldValue) {\r\n                    if (_.isArray(fieldValue)) {\r\n                        for (let obj of fieldValue) {\r\n                            if (obj instanceof Activity) {\r\n                                if (deep) {\r\n                                    yield * obj._children(deep, except, execContext, visited);\r\n                                }\r\n                                else {\r\n                                    yield obj;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (fieldValue instanceof Activity) {\r\n                        if (deep) {\r\n                            yield * fieldValue._children(deep, except, execContext, visited);\r\n                        }\r\n                        else {\r\n                            yield fieldValue;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n/* forEach */\r\n\r\n/* Structure */\r\nActivity.prototype.isArrayProperty = function (propName) {\r\n    return this.arrayProperties.has(propName);\r\n};\r\n\r\nActivity.prototype._initializeStructure = function (execContext) {\r\n    if (!this._structureInitialized) {\r\n        this.initializeStructure(execContext);\r\n        this._structureInitialized = true;\r\n    }\r\n};\r\n\r\nActivity.prototype.initializeStructure = _.noop;\r\n\r\nActivity.prototype.clone = function () {\r\n    function makeClone(value, canCloneArrays) {\r\n        if (value instanceof Activity) {\r\n            return value.clone();\r\n        }\r\n        else if (value instanceof Set) {\r\n            let newSet = new Set();\r\n            for (let item of value.values()) {\r\n                newSet.add(item);\r\n            }\r\n            return newSet;\r\n        }\r\n        else if (_.isArray(value)) {\r\n            if (canCloneArrays) {\r\n                let newArray = [];\r\n                for (let item of value) {\r\n                    newArray.push(makeClone(item, false));\r\n                }\r\n                return newArray;\r\n            }\r\n            else {\r\n                return value;\r\n            }\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n\r\n    let Constructor = this.constructor;\r\n    let newInst = new Constructor();\r\n    for (let key in this) {\r\n        if (this.hasOwnProperty(key)) {\r\n            let value = this[key];\r\n            if (newInst[key] !== value) {\r\n                newInst[key] = makeClone(value, true);\r\n            }\r\n        }\r\n    }\r\n    return newInst;\r\n};\r\n\r\n/* RUN */\r\nActivity.prototype.start = function (callContext) {\r\n    if (!(callContext instanceof CallContext)) {\r\n        throw new Error(\"Argument 'context' is not an instance of ActivityExecutionContext.\");\r\n    }\r\n\r\n    let args;\r\n    if (arguments.length > 1) {\r\n        args = [];\r\n        for (let i = 1; i < arguments.length; i++) {\r\n            args.push(arguments[i]);\r\n        }\r\n    }\r\n\r\n    this._start(callContext, null, args);\r\n};\r\n\r\nActivity.prototype._start = function (callContext, variables, args) {\r\n    let self = this;\r\n\r\n    if (_.isUndefined(args)) {\r\n        args = this.args || [];\r\n    }\r\n\r\n    if (!_.isArray(args)) {\r\n        args = [args];\r\n    }\r\n\r\n    let myCallContext = callContext.next(self, variables);\r\n    let state = myCallContext.executionState;\r\n    if (state.isRunning) {\r\n        throw new Error(\"Activity is already running.\");\r\n    }\r\n\r\n    // We should allow IO operations to execute:\r\n    setImmediate(\r\n        function () {\r\n            state.reportState(Activity.states.run, null, myCallContext.scope);\r\n            try {\r\n                self.initializeExec.call(myCallContext.scope);\r\n                self.run.call(myCallContext.scope, myCallContext, args);\r\n            }\r\n            catch (e) {\r\n                self.fail(myCallContext, e);\r\n            }\r\n        });\r\n};\r\n\r\nActivity.prototype.initializeExec = _.noop;\r\n\r\nActivity.prototype.unInitializeExec = _.noop;\r\n\r\nActivity.prototype.run = function (callContext, args) {\r\n    callContext.activity.complete(callContext, args);\r\n};\r\n\r\nActivity.prototype.complete = function (callContext, result) {\r\n    this.end(callContext, Activity.states.complete, result);\r\n};\r\n\r\nActivity.prototype.cancel = function (callContext) {\r\n    this.end(callContext, Activity.states.cancel);\r\n};\r\n\r\nActivity.prototype.idle = function (callContext) {\r\n    this.end(callContext, Activity.states.idle);\r\n};\r\n\r\nActivity.prototype.fail = function (callContext, e) {\r\n    this.end(callContext, Activity.states.fail, e);\r\n};\r\n\r\nActivity.prototype.end = function (callContext, reason, result) {\r\n    try {\r\n        this.unInitializeExec.call(callContext.scope, reason, result);\r\n    }\r\n    catch (e) {\r\n        let message = `unInitializeExec failed. Reason of ending was '${reason}' and the result is '${result}.`;\r\n        reason = Activity.states.fail;\r\n        result = e;\r\n    }\r\n\r\n    let state = callContext.executionState;\r\n\r\n    if (state.execState === Activity.states.cancel || state.execState === Activity.states.fail) {\r\n        // It was cancelled or failed:\r\n        return;\r\n    }\r\n\r\n    state.execState = reason;\r\n\r\n    let inIdle = reason === Activity.states.idle;\r\n    let execContext = callContext.executionContext;\r\n    let savedScope = callContext.scope;\r\n    savedScope.update(SimpleProxy.updateMode.oneWay);\r\n    callContext = callContext.back(inIdle);\r\n\r\n    if (callContext) {\r\n        try {\r\n            let bmName = specStrings.activities.createValueCollectedBMName(this.instanceId);\r\n            if (execContext.isBookmarkExists(bmName)) {\r\n                execContext.resumeBookmarkInScope(callContext, bmName, reason, result)\r\n                    .then(function() {\r\n                        state.emitState(result, savedScope);\r\n                    },\r\n                    function(e) {\r\n                        state.emitState(result, savedScope);\r\n                        callContext.fail(e);\r\n                    });\r\n                return;\r\n            }\r\n        }\r\n        catch (e) {\r\n            callContext.fail(e);\r\n        }\r\n    }\r\n    else {\r\n        // We're on root, done.\r\n        // If wf in idle, but there are internal bookmark resume request,\r\n        // then instead of emitting done, we have to continue them.\r\n        if (inIdle && execContext.processResumeBookmarkQueue()) {\r\n            // We should not emmit idle event, because there was internal bookmark continutations, so we're done.\r\n            return;\r\n        }\r\n    }\r\n    state.emitState(result, savedScope);\r\n};\r\n\r\nActivity.prototype._defaultEndCallback = function (callContext, reason, result) {\r\n    callContext.end(reason, result);\r\n};\r\n\r\nActivity.prototype.schedule = function (callContext, obj, endCallback) {\r\n    let self = this;\r\n    let scope = callContext.scope;\r\n    let execContext = callContext.executionContext;\r\n    let selfId = callContext.instanceId;\r\n\r\n    if (!endCallback) {\r\n        endCallback = \"_defaultEndCallback\";\r\n    }\r\n\r\n    let invokeEndCallback = function (_reason, _result) {\r\n        setImmediate(function () {\r\n            scope[endCallback].call(scope, callContext, _reason, _result);\r\n        });\r\n    };\r\n\r\n    if (!_.isString(endCallback)) {\r\n        callContext.fail(new TypeError(\"Provided argument 'endCallback' value is not a string.\"));\r\n        return;\r\n    }\r\n    let cb = scope[endCallback];\r\n    if (!_.isFunction(cb)) {\r\n        callContext.fail(new TypeError(`'${endCallback}' is not a function.`));\r\n        return;\r\n    }\r\n\r\n    if (scope.__schedulingState) {\r\n        debug(\"%s: Error, already existsing state: %j\", selfId, scope.__schedulingState);\r\n        callContext.fail(new errors.ActivityStateExceptionError(\"There are already scheduled items exists.\"));\r\n        return;\r\n    }\r\n\r\n    debug(\"%s: Scheduling object(s) by using end callback '%s': %j\", selfId, endCallback, obj);\r\n\r\n    let state =\r\n    {\r\n        many: _.isArray(obj),\r\n        indices: new Map(),\r\n        results: [],\r\n        total: 0,\r\n        idleCount: 0,\r\n        cancelCount: 0,\r\n        completedCount: 0,\r\n        endBookmarkName: null,\r\n        endCallbackName: endCallback\r\n    };\r\n\r\n    let bookmarkNames = [];\r\n    try {\r\n        let startedAny = false;\r\n        let index = 0;\r\n        let processValue = function (value) {\r\n            debug(\"%s: Checking value: %j\", selfId, value);\r\n            let activity, variables = null;\r\n            if (value instanceof Activity) {\r\n                activity = value;\r\n            }\r\n            else if (_.isObject(value) && value.activity instanceof Activity) {\r\n                activity = value.activity;\r\n                variables = _.isObject(value.variables) ? value.variables : null;\r\n            }\r\n            if (activity) {\r\n                let instanceId = activity.instanceId;\r\n                debug(\"%s: Value is an activity with instance id: %s\", selfId, instanceId);\r\n                if (state.indices.has(instanceId)) {\r\n                    throw new errors.ActivityStateExceptionError(`Activity instance '${instanceId} has been scheduled already.`);\r\n                }\r\n                debug(\"%s: Creating end bookmark, and starting it.\", selfId);\r\n                bookmarkNames.push(execContext.createBookmark(selfId, specStrings.activities.createValueCollectedBMName(instanceId), \"resultCollected\"));\r\n                activity._start(callContext, variables);\r\n                startedAny = true;\r\n                state.indices.set(instanceId, index);\r\n                state.results.push(null);\r\n                state.total++;\r\n            }\r\n            else {\r\n                debug(\"%s: Value is not an activity.\", selfId);\r\n                state.results.push(value);\r\n            }\r\n        };\r\n        if (state.many) {\r\n            debug(\"%s: There are many values, iterating.\", selfId);\r\n            for (let value of obj) {\r\n                processValue(value);\r\n                index++;\r\n            }\r\n        }\r\n        else {\r\n            processValue(obj);\r\n        }\r\n        if (!startedAny) {\r\n            debug(\"%s: No activity has been started, calling end callback with original object.\", selfId);\r\n            let result = state.many ? state.results : state.results[0];\r\n            invokeEndCallback(Activity.states.complete, result);\r\n        }\r\n        else {\r\n            debug(\"%s: %d activities has been started. Registering end bookmark.\", selfId, state.indices.size);\r\n            let endBM = specStrings.activities.createCollectingCompletedBMName(selfId);\r\n            bookmarkNames.push(execContext.createBookmark(selfId, endBM, endCallback));\r\n            state.endBookmarkName = endBM;\r\n            scope.__schedulingState = state;\r\n        }\r\n        scope.update(SimpleProxy.updateMode.oneWay);\r\n    }\r\n    catch (e) {\r\n        debug(\"%s: Runtime error happened: %s\", selfId, e.stack);\r\n        if (bookmarkNames.length) {\r\n            debug(\"%s: Set bookmarks to noop: $j\", selfId, bookmarkNames);\r\n            execContext.noopCallbacks(bookmarkNames);\r\n        }\r\n        scope.delete(\"__schedulingState\");\r\n        debug(\"%s: Invoking end callback with the error.\", selfId);\r\n        invokeEndCallback(Activity.states.fail, e);\r\n    }\r\n    finally {\r\n        debug(\"%s: Final state indices count: %d, total: %d\", selfId, state.indices.size, state.total);\r\n    }\r\n};\r\n\r\nActivity.prototype.resultCollected = function (callContext, reason, result, bookmark) {\r\n    let selfId = callContext.instanceId;\r\n    let execContext = callContext.executionContext;\r\n    let childId = specStrings.getString(bookmark.name);\r\n    debug(\"%s: Scheduling result item collected, childId: %s, reason: %s, result: %j, bookmark: %j\", selfId, childId, reason, result, bookmark);\r\n\r\n    let finished = null;\r\n    let state = this.__schedulingState;\r\n    let fail = false;\r\n    try {\r\n        if (!_.isObject(state)) {\r\n            throw new errors.ActivityStateExceptionError(\"Value of __schedulingState is '\" + state + \"'.\");\r\n        }\r\n        let index = state.indices.get(childId);\r\n        if (_.isUndefined(index)) {\r\n            throw new errors.ActivityStateExceptionError(`Child activity of '${childId}' scheduling state index out of range.`);\r\n        }\r\n\r\n        debug(\"%s: Finished child activity id is: %s\", selfId, childId);\r\n\r\n        switch (reason) {\r\n            case Activity.states.complete:\r\n                debug(\"%s: Setting %d. value to result: %j\", selfId, index, result);\r\n                state.results[index] = result;\r\n                debug(\"%s: Removing id from state.\", selfId);\r\n                state.indices.delete(childId);\r\n                state.completedCount++;\r\n                break;\r\n            case Activity.states.fail:\r\n                debug(\"%s: Failed with: %s\", selfId, result.stack);\r\n                fail = true;\r\n                state.indices.delete(childId);\r\n                break;\r\n            case Activity.states.cancel:\r\n                debug(\"%s: Incrementing cancel counter.\", selfId);\r\n                state.cancelCount++;\r\n                debug(\"%s: Removing id from state.\", selfId);\r\n                state.indices.delete(childId);\r\n                break;\r\n            case Activity.states.idle:\r\n                debug(\"%s: Incrementing idle counter.\", selfId);\r\n                state.idleCount++;\r\n                break;\r\n            default:\r\n                throw new errors.ActivityStateExceptionError(`Result collected with unknown reason '${reason}'.`);\r\n        }\r\n\r\n        debug(\"%s: State so far = total: %s, indices count: %d, completed count: %d, cancel count: %d, error count: %d, idle count: %d\",\r\n            selfId,\r\n            state.total,\r\n            state.indices.size,\r\n            state.completedCount,\r\n            state.cancelCount,\r\n            state.idleCount);\r\n\r\n        let endWithNoCollectAll = !callContext.activity.collectAll && reason !== Activity.states.idle;\r\n        if (endWithNoCollectAll || fail) {\r\n            if (!fail) {\r\n                debug(\"%s: ---- Collecting of values ended, because we're not collecting all values (eg.: Pick).\", selfId);\r\n            }\r\n            else {\r\n                debug(\"%s: ---- Collecting of values ended, because of an error.\", selfId);\r\n            }\r\n            debug(\"%s: Shutting down %d other, running acitvities.\", selfId, state.indices.size);\r\n            let ids = [];\r\n            for (let id of state.indices.keys()) {\r\n                ids.push(id);\r\n                debug(\"%s: Deleting scope of activity: %s\", selfId, id);\r\n                execContext.deleteScopeOfActivity(callContext, id);\r\n                let ibmName = specStrings.activities.createValueCollectedBMName(id);\r\n                debug(\"%s: Deleting value collected bookmark: %s\", selfId, ibmName);\r\n                execContext.deleteBookmark(ibmName);\r\n            }\r\n            execContext.cancelExecution(this, ids);\r\n            debug(\"%s: Activities cancelled: %j\", selfId, ids);\r\n            debug(\"%s: Reporting the actual reason: %s and result: %j\", selfId, reason, result);\r\n            finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, reason, result); };\r\n        }\r\n        else {\r\n            assert(!fail);\r\n            let onEnd = (state.indices.size - state.idleCount) === 0;\r\n            if (onEnd) {\r\n                debug(\"%s: ---- Collecting of values ended (ended because of collect all is off: %s).\", selfId, endWithNoCollectAll);\r\n                if (state.cancelCount) {\r\n                    debug(\"%s: Collecting has been cancelled, resuming end bookmarks.\", selfId);\r\n                    finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.cancel); };\r\n                }\r\n                else if (state.idleCount) {\r\n                    debug(\"%s: This entry has been gone to idle, propagating counter.\", selfId);\r\n                    state.idleCount--; // Because the next call will wake up a thread.\r\n                    execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.idle);\r\n                }\r\n                else {\r\n                    result = state.many ? state.results : state.results[0];\r\n                    debug(\"%s: This entry has been completed, resuming collect bookmark with the result(s): %j\", selfId, result);\r\n                    finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.complete, result); };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        callContext.fail(e);\r\n        this.delete(\"__schedulingState\");\r\n    }\r\n    finally {\r\n        if (finished) {\r\n            debug(\"%s: Schduling finished, removing state.\", selfId);\r\n            this.delete(\"__schedulingState\");\r\n\r\n            finished();\r\n        }\r\n    }\r\n};\r\n/* RUN */\r\n\r\n/* SCOPE */\r\nActivity.prototype._getScopeKeys = function () {\r\n    let self = this;\r\n    if (!self._scopeKeys || !self._structureInitialized) {\r\n        self._scopeKeys = [];\r\n        for (let key in self) {\r\n            if (!self.nonScopedProperties.has(key) &&\r\n                (_.isUndefined(Activity.prototype[key]) || key === \"_defaultEndCallback\" || key === \"_subActivitiesGot\")) {\r\n                self._scopeKeys.push(key);\r\n            }\r\n        }\r\n    }\r\n    return self._scopeKeys;\r\n};\r\n\r\nActivity.prototype.createScopePart = function () {\r\n    if (!this._structureInitialized) {\r\n        throw new errors.ActivityRuntimeError(\"Cannot create activity scope for uninitialized activities.\");\r\n    }\r\n\r\n    if (this._createScopePartImpl === null) {\r\n        let first = true;\r\n        let src = \"return {\";\r\n        for (let fieldName of this._getScopeKeys()) {\r\n            if (first) {\r\n                first = false;\r\n            }\r\n            else {\r\n                src += \",\\n\";\r\n            }\r\n            src += fieldName + \":a.\" + fieldName;\r\n        }\r\n        src += \"}\";\r\n\r\n        try {\r\n            this._createScopePartImpl = new Function(\"a,_\", src);\r\n        }\r\n        catch (e) {\r\n            debug(\"Invalid scope part function:%s\", src);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    return this._createScopePartImpl(this, _);\r\n};\r\n/* SCOPE */\r\n\r\nActivity.states = enums.activityStates;\r\n\r\nmodule.exports = Activity;\r\n"],"file":"activities/activity.js","sourceRoot":"/source/"}