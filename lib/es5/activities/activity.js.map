{"version":3,"names":[],"mappings":"","sources":["activities/activity.js"],"sourcesContent":["/*jshint -W054 */\n\n\"use strict\";\n\nlet constants = require(\"../common/constants\");\nlet errors = require(\"../common/errors\");\nlet enums = require(\"../common/enums\");\nlet _ = require(\"lodash\");\nlet specStrings = require(\"../common/specStrings\");\nlet util = require(\"util\");\nlet is = require(\"../common/is\");\nlet CallContext = require(\"./callContext\");\nlet uuid = require('node-uuid');\nlet async = require(\"../common/asyncHelpers\").async;\nlet assert = require(\"better-assert\");\nlet debug = require(\"debug\")(\"wf4node:Activity\");\nlet common = require(\"../common\");\nlet SimpleProxy = common.SimpleProxy;\n\nfunction Activity() {\n    this.args = null;\n    this.displayName = null;\n    this.id = uuid.v4();\n    this._structureInitialized = false;\n    this._scopeKeys = null;\n    this[\"@require\"] = null;\n\n    // Properties not serialized:\n    this.nonSerializedProperties = new Set();\n\n    // Properties are not going to copied in the scope:\n    this.nonScopedProperties = new Set();\n    this.nonScopedProperties.add(\"nonScopedProperties\");\n    this.nonScopedProperties.add(\"nonSerializedProperties\");\n    this.nonScopedProperties.add(\"arrayProperties\");\n    this.nonScopedProperties.add(\"activity\");\n    this.nonScopedProperties.add(\"id\");\n    this.nonScopedProperties.add(\"args\");\n    this.nonScopedProperties.add(\"displayName\");\n    this.nonScopedProperties.add(\"complete\");\n    this.nonScopedProperties.add(\"cancel\");\n    this.nonScopedProperties.add(\"idle\");\n    this.nonScopedProperties.add(\"fail\");\n    this.nonScopedProperties.add(\"end\");\n    this.nonScopedProperties.add(\"schedule\");\n    this.nonScopedProperties.add(\"createBookmark\");\n    this.nonScopedProperties.add(\"resumeBookmark\");\n    this.nonScopedProperties.add(\"resultCollected\");\n    this.nonScopedProperties.add(\"codeProperties\");\n    this.nonScopedProperties.add(\"initializeStructure\");\n    this.nonScopedProperties.add(\"_initializeStructure\");\n    this.nonScopedProperties.add(\"_structureInitialized\");\n    this.nonScopedProperties.add(\"clone\");\n    this.nonScopedProperties.add(\"_scopeKeys\");\n    this.nonScopedProperties.add(\"_createScopePartImpl\");\n    this.nonScopedProperties.add(\"@require\");\n    this.nonScopedProperties.add(\"initializeExec\");\n    this.nonScopedProperties.add(\"unInitializeExec\");\n\n    this.codeProperties = new Set();\n    this.arrayProperties = new Set([\"args\"]);\n}\n\nObject.defineProperties(Activity.prototype, {\n    _scopeKeys: {\n        value: null,\n        writable: true,\n        enumerable: false\n    },\n    _createScopePartImpl: {\n        value: null,\n        writable: true,\n        enumerable: false\n    },\n    collectAll: {\n        value: true,\n        writable: false,\n        enumerable: false\n    }\n});\n\nActivity.prototype.getInstanceId = function (execContext) {\n    return execContext.getInstanceId(this);\n};\n\nActivity.prototype.toString = function () {\n    return (this.displayName ? (this.displayName + \" \") : \"\") + \"(\" + this.constructor.name + \":\" + this.id + \")\";\n};\n\n/* forEach */\nActivity.prototype.all = function* (execContext) {\n    yield * this._children(true, null, execContext, null);\n};\n\nActivity.prototype.children = function* (execContext) {\n    yield * this._children(true, this, execContext, null);\n};\n\nActivity.prototype.immediateChildren = function* (execContext) {\n    yield * this._children(false, this, execContext);\n};\n\nActivity.prototype._children = function* (deep, except, execContext, visited) {\n    assert(execContext instanceof require(\"./activityExecutionContext\"), \"Cannot enumerate activities without an execution context.\");\n    visited = visited || new Set();\n    let self = this;\n    if (!visited.has(self)) {\n        visited.add(self);\n\n        // Ensure it's structure created:\n        this._initializeStructure(execContext);\n\n        if (self !== except) {\n            yield self;\n        }\n\n        for (let fieldName in self) {\n            let fieldValue = self[fieldName];\n            if (fieldValue) {\n                if (_.isArray(fieldValue)) {\n                    for (let obj of fieldValue) {\n                        if (obj instanceof Activity) {\n                            if (deep) {\n                                yield * obj._children(deep, except, execContext, visited);\n                            }\n                            else {\n                                yield obj;\n                            }\n                        }\n                    }\n                }\n                else if (fieldValue instanceof Activity) {\n                    if (deep) {\n                        yield * fieldValue._children(deep, except, execContext, visited);\n                    }\n                    else {\n                        yield fieldValue;\n                    }\n                }\n            }\n        }\n    }\n};\n/* forEach */\n\n/* Structure */\nActivity.prototype.isArrayProperty = function (propName) {\n    return this.arrayProperties.has(propName);\n};\n\nActivity.prototype._initializeStructure = function (execContext) {\n    assert(!!execContext);\n    if (!this._structureInitialized) {\n        this.initializeStructure(execContext);\n        this._structureInitialized = true;\n    }\n};\n\nActivity.prototype.initializeStructure = _.noop;\n\nActivity.prototype.clone = function () {\n    function makeClone(value, canCloneArrays) {\n        if (value instanceof Activity) {\n            return value.clone();\n        }\n        else if (value instanceof Set) {\n            let newSet = new Set();\n            for (let item of value.values()) {\n                newSet.add(item);\n            }\n            return newSet;\n        }\n        else if (_.isArray(value)) {\n            if (canCloneArrays) {\n                let newArray = [];\n                for (let item of value) {\n                    newArray.push(makeClone(item, false));\n                }\n                return newArray;\n            }\n            else {\n                throw new Error(\"Cannot clone activity's nested arrays.\");\n            }\n        }\n        else {\n            return value;\n        }\n    }\n\n    let Constructor = this.constructor;\n    let newInst = new Constructor();\n    for (let key in this) {\n        if (this.hasOwnProperty(key)) {\n            let value = this[key];\n            if (newInst[key] !== value) {\n                newInst[key] = makeClone(value, true);\n            }\n        }\n    }\n    return newInst;\n};\n\n/* RUN */\nActivity.prototype.start = function (callContext) {\n    let self = this;\n\n    if (!(callContext instanceof CallContext)) {\n        throw new Error(\"Argument 'context' is not an instance of ActivityExecutionContext.\");\n    }\n\n    let args = self.args;\n    if (arguments.length > 1) {\n        args = [];\n        for (let i = 1; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n    }\n\n    this._start(callContext, null, args);\n};\n\nActivity.prototype._start = function (callContext, variables, args) {\n    let self = this;\n\n    args = args || self.args || [];\n\n    if (!_.isArray(args)) {\n        args = [args];\n    }\n\n    let myCallContext = callContext.next(self, variables);\n    let state = myCallContext.executionState;\n    if (state.isRunning) {\n        throw new Error(\"Activity is already running.\");\n    }\n\n    // We should allow IO operations to execute:\n    setImmediate(\n        function () {\n            state.reportState(Activity.states.run, null, myCallContext.scope);\n            try {\n                self.initializeExec.call(myCallContext.scope);\n                self.run.call(myCallContext.scope, myCallContext, args);\n            }\n            catch (e) {\n                self.fail(myCallContext, e);\n            }\n        });\n};\n\nActivity.prototype.initializeExec = _.noop;\n\nActivity.prototype.unInitializeExec = _.noop;\n\nActivity.prototype.run = function (callContext, args) {\n    callContext.activity.complete(callContext, args);\n};\n\nActivity.prototype.complete = function (callContext, result) {\n    this.end(callContext, Activity.states.complete, result);\n};\n\nActivity.prototype.cancel = function (callContext) {\n    this.end(callContext, Activity.states.cancel);\n};\n\nActivity.prototype.idle = function (callContext) {\n    this.end(callContext, Activity.states.idle);\n};\n\nActivity.prototype.fail = function (callContext, e) {\n    this.end(callContext, Activity.states.fail, e);\n};\n\nActivity.prototype.end = function (callContext, reason, result) {\n    try {\n        this.unInitializeExec.call(callContext.scope, reason, result);\n    }\n    catch (e) {\n        let message = `unInitializeExec failed. Reason of ending was '${reason}' and the result is '${result}.`;\n        reason = Activity.states.fail;\n        result = e;\n    }\n\n    let state = callContext.executionState;\n\n    if (state.execState === Activity.states.cancel || state.execState === Activity.states.fail) {\n        // It was cancelled or failed:\n        return;\n    }\n\n    state.execState = reason;\n\n    let inIdle = reason === Activity.states.idle;\n    let execContext = callContext.executionContext;\n    let savedScope = callContext.scope;\n    savedScope.update(SimpleProxy.updateMode.oneWay);\n    callContext = callContext.back(inIdle);\n\n    if (callContext) {\n        try {\n            let bmName = specStrings.activities.createValueCollectedBMName(this.getInstanceId(execContext));\n            if (execContext.isBookmarkExists(bmName)) {\n                execContext.resumeBookmarkInScope(callContext, bmName, reason, result)\n                    .then(function() {\n                        state.emitState(result, savedScope);\n                    },\n                    function(e) {\n                        state.emitState(result, savedScope);\n                        callContext.fail(e);\n                    });\n                return;\n            }\n        }\n        catch (e) {\n            callContext.fail(e);\n        }\n    }\n    else {\n        // We're on root, done.\n        // If wf in idle, but there are internal bookmark resume request,\n        // then instead of emitting done, we have to continue them.\n        if (inIdle && execContext.processResumeBookmarkQueue()) {\n            // We should not emmit idle event, because there was internal bookmark continutations, so we're done.\n            return;\n        }\n    }\n    state.emitState(result, savedScope);\n};\n\nActivity.prototype._defaultEndCallback = function (callContext, reason, result) {\n    callContext.end(reason, result);\n};\n\nActivity.prototype.schedule = function (callContext, obj, endCallback) {\n    let self = this;\n    let scope = callContext.scope;\n    let execContext = callContext.executionContext;\n    let selfId = callContext.instanceId;\n\n    if (!endCallback) {\n        endCallback = \"_defaultEndCallback\";\n    }\n\n    let invokeEndCallback = function (_reason, _result) {\n        setImmediate(function () {\n            scope[endCallback].call(scope, callContext, _reason, _result);\n        });\n    };\n\n    if (!_.isString(endCallback)) {\n        callContext.fail(new TypeError(\"Provided argument 'endCallback' value is not a string.\"));\n        return;\n    }\n    let cb = scope[endCallback];\n    if (!_.isFunction(cb)) {\n        callContext.fail(new TypeError(`'${endCallback}' is not a function.`));\n        return;\n    }\n\n    if (scope.__schedulingState) {\n        debug(\"%s: Error, already existsing state: %j\", selfId, scope.__schedulingState);\n        callContext.fail(new errors.ActivityStateExceptionError(\"There are already scheduled items exists.\"));\n        return;\n    }\n\n    debug(\"%s: Scheduling object(s) by using end callback '%s': %j\", selfId, endCallback, obj);\n\n    let state =\n    {\n        many: _.isArray(obj),\n        indices: new Map(),\n        results: [],\n        total: 0,\n        idleCount: 0,\n        cancelCount: 0,\n        completedCount: 0,\n        endBookmarkName: null,\n        endCallbackName: endCallback\n    };\n\n    let bookmarkNames = [];\n    try {\n        let startedAny = false;\n        let index = 0;\n        let processValue = function (value) {\n            debug(\"%s: Checking value: %j\", selfId, value);\n            let activity, variables = null;\n            if (value instanceof Activity) {\n                activity = value;\n            }\n            else if (_.isObject(value) && value.activity instanceof Activity) {\n                activity = value.activity;\n                variables = _.isObject(value.variables) ? value.variables : null;\n            }\n            if (activity) {\n                let instanceId = activity.getInstanceId(execContext);\n                debug(\"%s: Value is an activity with instance id: %s\", selfId, instanceId);\n                if (state.indices.has(instanceId)) {\n                    throw new errors.ActivityStateExceptionError(`Activity instance '${instanceId} has been scheduled already.`);\n                }\n                debug(\"%s: Creating end bookmark, and starting it.\", selfId);\n                bookmarkNames.push(execContext.createBookmark(selfId, specStrings.activities.createValueCollectedBMName(instanceId), \"resultCollected\"));\n                activity._start(callContext, variables);\n                startedAny = true;\n                state.indices.set(instanceId, index);\n                state.results.push(null);\n                state.total++;\n            }\n            else {\n                debug(\"%s: Value is not an activity.\", selfId);\n                state.results.push(value);\n            }\n        };\n        if (state.many) {\n            debug(\"%s: There are many values, iterating.\", selfId);\n            for (let value of obj) {\n                processValue(value);\n                index++;\n            }\n        }\n        else {\n            processValue(obj);\n        }\n        if (!startedAny) {\n            debug(\"%s: No activity has been started, calling end callback with original object.\", selfId);\n            let result = state.many ? state.results : state.results[0];\n            invokeEndCallback(Activity.states.complete, result);\n        }\n        else {\n            debug(\"%s: %d activities has been started. Registering end bookmark.\", selfId, state.indices.size);\n            let endBM = specStrings.activities.createCollectingCompletedBMName(selfId);\n            bookmarkNames.push(execContext.createBookmark(selfId, endBM, endCallback));\n            state.endBookmarkName = endBM;\n            scope.__schedulingState = state;\n        }\n        scope.update(SimpleProxy.updateMode.oneWay);\n    }\n    catch (e) {\n        debug(\"%s: Runtime error happened: %s\", selfId, e.stack);\n        if (bookmarkNames.length) {\n            debug(\"%s: Set bookmarks to noop: $j\", selfId, bookmarkNames);\n            execContext.noopCallbacks(bookmarkNames);\n        }\n        scope.delete(\"__schedulingState\");\n        debug(\"%s: Invoking end callback with the error.\", selfId);\n        invokeEndCallback(Activity.states.fail, e);\n    }\n    finally {\n        debug(\"%s: Final state indices count: %d, total: %d\", selfId, state.indices.size, state.total);\n    }\n};\n\nActivity.prototype.resultCollected = function (callContext, reason, result, bookmark) {\n    let selfId = callContext.instanceId;\n    let execContext = callContext.executionContext;\n    let childId = specStrings.getString(bookmark.name);\n    debug(\"%s: Scheduling result item collected, childId: %s, reason: %s, result: %j, bookmark: %j\", selfId, childId, reason, result, bookmark);\n\n    let finished = null;\n    let state = this.__schedulingState;\n    let fail = false;\n    try {\n        if (!_.isObject(state)) {\n            throw new errors.ActivityStateExceptionError(\"Value of __schedulingState is '\" + state + \"'.\");\n        }\n        let index = state.indices.get(childId);\n        if (_.isUndefined(index)) {\n            throw new errors.ActivityStateExceptionError(`Child activity of '${childId}' scheduling state index out of range.`);\n        }\n\n        debug(\"%s: Finished child activity id is: %s\", selfId, childId);\n\n        switch (reason) {\n            case Activity.states.complete:\n                debug(\"%s: Setting %d. value to result: %j\", selfId, index, result);\n                state.results[index] = result;\n                debug(\"%s: Removing id from state.\", selfId);\n                state.indices.delete(childId);\n                state.completedCount++;\n                break;\n            case Activity.states.fail:\n                debug(\"%s: Failed with: %s\", selfId, result.stack);\n                fail = true;\n                state.indices.delete(childId);\n                break;\n            case Activity.states.cancel:\n                debug(\"%s: Incrementing cancel counter.\", selfId);\n                state.cancelCount++;\n                debug(\"%s: Removing id from state.\", selfId);\n                state.indices.delete(childId);\n                break;\n            case Activity.states.idle:\n                debug(\"%s: Incrementing idle counter.\", selfId);\n                state.idleCount++;\n                break;\n            default:\n                throw new errors.ActivityStateExceptionError(`Result collected with unknown reason '${reason}'.`);\n        }\n\n        debug(\"%s: State so far = total: %s, indices count: %d, completed count: %d, cancel count: %d, error count: %d, idle count: %d\",\n            selfId,\n            state.total,\n            state.indices.size,\n            state.completedCount,\n            state.cancelCount,\n            state.idleCount);\n\n        let endWithNoCollectAll = !callContext.activity.collectAll && reason !== Activity.states.idle;\n        if (endWithNoCollectAll || fail) {\n            if (!fail) {\n                debug(\"%s: ---- Collecting of values ended, because we're not collecting all values (eg.: Pick).\", selfId);\n            }\n            else {\n                debug(\"%s: ---- Collecting of values ended, because of an error.\", selfId);\n            }\n            debug(\"%s: Shutting down %d other, running acitvities.\", selfId, state.indices.size);\n            let ids = [];\n            for (let id of state.indices.keys()) {\n                ids.push(id);\n                debug(\"%s: Deleting scope of activity: %s\", selfId, id);\n                execContext.deleteScopeOfActivity(callContext, id);\n                let ibmName = specStrings.activities.createValueCollectedBMName(id);\n                debug(\"%s: Deleting value collected bookmark: %s\", selfId, ibmName);\n                execContext.deleteBookmark(ibmName);\n            }\n            execContext.cancelExecution(this, ids);\n            debug(\"%s: Activities cancelled: %j\", selfId, ids);\n            debug(\"%s: Reporting the actual reason: %s and result: %j\", selfId, reason, result);\n            finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, reason, result); };\n        }\n        else {\n            assert(!fail);\n            let onEnd = (state.indices.size - state.idleCount) === 0;\n            if (onEnd) {\n                debug(\"%s: ---- Collecting of values ended (ended because of collect all is off: %s).\", selfId, endWithNoCollectAll);\n                if (state.cancelCount) {\n                    debug(\"%s: Collecting has been cancelled, resuming end bookmarks.\", selfId);\n                    finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.cancel); };\n                }\n                else if (state.idleCount) {\n                    debug(\"%s: This entry has been gone to idle, propagating counter.\", selfId);\n                    state.idleCount--; // Because the next call will wake up a thread.\n                    execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.idle);\n                }\n                else {\n                    result = state.many ? state.results : state.results[0];\n                    debug(\"%s: This entry has been completed, resuming collect bookmark with the result(s): %j\", selfId, result);\n                    finished = function () { execContext.resumeBookmarkInScope(callContext, state.endBookmarkName, Activity.states.complete, result); };\n                }\n            }\n        }\n    }\n    catch (e) {\n        callContext.fail(e);\n        this.delete(\"__schedulingState\");\n    }\n    finally {\n        if (finished) {\n            debug(\"%s: Schduling finished, removing state.\", selfId);\n            this.delete(\"__schedulingState\");\n\n            finished();\n        }\n    }\n};\n/* RUN */\n\n/* SCOPE */\nActivity.prototype._getScopeKeys = function () {\n    let self = this;\n    if (!self._scopeKeys || !self._structureInitialized) {\n        self._scopeKeys = [];\n        for (let key in self) {\n            if (!self.nonScopedProperties.has(key) && (_.isUndefined(Activity.prototype[key]) || key === \"_defaultEndCallback\" || key === \"_subActivitiesGot\")) {\n                self._scopeKeys.push(key);\n            }\n        }\n    }\n    return self._scopeKeys;\n};\n\nActivity.prototype.createScopePart = function () {\n    if (!this._structureInitialized) {\n        throw new errors.ActivityRuntimeError(\"Cannot create activity scope for uninitialized activities.\");\n    }\n\n    if (this._createScopePartImpl === null) {\n        let first = true;\n        let src = \"return {\";\n        for (let fieldName of this._getScopeKeys()) {\n            if (first) {\n                first = false;\n            }\n            else {\n                src += \",\\n\";\n            }\n            if (_.isPlainObject(this[fieldName])) {\n                src += fieldName + \":_.clone(a.\" + fieldName + \", true)\";\n            }\n            else if (_.isArray(this[fieldName])) {\n                src += fieldName + \":a.\" + fieldName + \".slice(0)\";\n            }\n            else {\n                src += fieldName + \":a.\" + fieldName;\n            }\n        }\n        src += \"}\";\n\n        try {\n            this._createScopePartImpl = new Function(\"a,_\", src);\n        }\n        catch (e) {\n            debug(\"Invalid scope part function:%s\", src);\n            throw e;\n        }\n    }\n\n    return this._createScopePartImpl(this, _);\n};\n/* SCOPE */\n\nActivity.states = enums.activityStates;\n\nmodule.exports = Activity;\n"],"file":"activities/activity.js","sourceRoot":"/source/"}