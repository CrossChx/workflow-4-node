{"version":3,"names":[],"mappings":"","sources":["activities/scopeTree.js"],"sourcesContent":["\"use strict\";\n\nlet ScopeNode = require(\"./scopeNode\");\nlet constants = require(\"../common/constants\");\nlet _ = require(\"lodash\");\nlet specStrings = require(\"../common/specStrings\");\nlet errors = require(\"../common/errors\");\nlet is = require(\"../common/is\");\nlet scope = require(\"./scope\");\nlet Expression = require(\"./expression\");\nlet scopeSerializer = require(\"./scopeSerializer\");\n\nfunction ScopeTree(initialScope, getActivityByIdFunc) {\n    this._initialNode = new ScopeNode(constants.ids.initialScope, initialScope);\n    this._nodes = new Map();\n    this._nodes.set(this._initialNode.instanceId, this._initialNode);\n    this._getActivityById = getActivityByIdFunc;\n}\n\n/* SERIALIZATION */\nScopeTree.prototype.getExecutionState = function (execContext, enablePromotions, serializer) {\n    return scopeSerializer.serialize(execContext, this._getActivityById, enablePromotions, this._nodes.values(), serializer);\n};\n\nScopeTree.prototype.setState = function (json, serializer) {\n    if (!_.isArray(json)) {\n        throw new TypeError(\"Array argument expected.\");\n    }\n\n    if (this._nodes.count !== 1) {\n        let prev = this._nodes;\n        this._nodes = new Map();\n        this._nodes.set(constants.ids.initialScope, prev.get(constants.ids.initialScope));\n        this._initialNode.clearChildren();\n    }\n\n    try {\n        // Create nodes:\n        for (let node of scopeSerializer.deserializeNodes(this._getActivityById, json, serializer)) {\n            this._nodes.set(node.instanceId, node);\n        }\n        // Setup Tree:\n        for (let item of json) {\n            this._nodes.get(item.instanceId).parent = this._nodes.get(item.parentId);\n        }\n        // Setup specials:\n        for (let node of this._nodes.values()) {\n            for (let key of node._keys) {\n                let value = node.scopePart[key];\n                if (value && value.$type === constants.markers.$parent) {\n                    let parentScope = scope.create(this, this._nodes.get(value.id), true);\n                    parentScope.__marker = constants.markers.$parent;\n                    node.scopePart[key] = parentScope;\n                }\n            }\n        }\n    }\n    catch (e) {\n        throw new errors.WorkflowError(\"Cannot restore state tree, because data is corrupt. Inner error: \" + e.stack);\n    }\n};\n/* SERIALIZATION */\n\n/* PROXY */\n\nScopeTree.prototype._getRealParent = function (currentNode) {\n    let parent = currentNode.parent;\n    if (this._getActivityById(currentNode.instanceId) instanceof Expression) {\n        parent = parent.parent;\n    }\n    return parent;\n};\n\nScopeTree.prototype.hasProperty = function (currentNode, name, noWalk) {\n    if (name === \"$parent\") {\n        let parent = this._getRealParent(currentNode);\n        if (parent && parent !== this._initialNode) {\n            return !!parent;\n        }\n    }\n\n    if (name === \"$activity\") {\n        return true;\n    }\n\n    let found = false;\n    for (let node of currentNode.walkToRoot(noWalk)) {\n        if (node.isPropertyExists(name)) {\n            found = true;\n            break;\n        }\n        if (node.userId === name) {\n            found = true;\n            break;\n        }\n    }\n    return found;\n};\n\nScopeTree.prototype.getValue = function (currentNode, name, noWalk) {\n    let self = this;\n\n    if (name === \"$parent\") {\n        let parent = this._getRealParent(currentNode);\n        if (parent && parent !== this._initialNode) {\n            let parentScope = scope.create(this, parent, true);\n            parentScope.__marker = constants.markers.$parent;\n            return parentScope;\n        }\n        else {\n            return undefined;\n        }\n    }\n\n    if (name === \"$activity\") {\n        return self._getActivityById(currentNode.instanceId);\n    }\n\n    let canReturnPrivate = true;\n    let value;\n    for (let node of currentNode.walkToRoot(noWalk)) {\n        if (!_.isUndefined(value = node.getPropertyValue(name, canReturnPrivate))) {\n            break;\n        }\n        if (node.userId === name && node !== currentNode) {\n            value = scope.create(self, node, true);\n            break;\n        }\n        canReturnPrivate = false;\n    }\n    return value;\n};\n\nScopeTree.prototype.setValue = function (currentNode, name, value, noWalk) {\n    if (this.isOnInitial) {\n        throw new Error(\"Cannot set property of the initial scope.\");\n    }\n\n    let self = this;\n    let canSetPrivate = true;\n    let setDone = false;\n    for (let node of currentNode.walkToRoot(noWalk)) {\n        if (node === self._initialNode) {\n            break;\n        }\n        if (node.setPropertyValue(name, value, canSetPrivate)) {\n            setDone = true;\n            break;\n        }\n        canSetPrivate = false;\n    }\n\n    if (!setDone) {\n        currentNode.createPropertyWithValue(name, value);\n    }\n\n    return true;\n};\n\nScopeTree.prototype.deleteProperty = function (currentNode, name, noWalk) {\n    let self = this;\n    let canDeletePrivate = true;\n    let deleteDone = false;\n    for (let node of currentNode.walkToRoot(noWalk)) {\n        if (node === self._initialNode) {\n            break;\n        }\n        if (node.deleteProperty(name, canDeletePrivate)) {\n            deleteDone = true;\n            break;\n        }\n        canDeletePrivate = false;\n    }\n\n    return deleteDone;\n};\n\nScopeTree.prototype.enumeratePropertyNames = function* (currentNode, noWalk) {\n    let canEnumeratePrivate = true;\n    let node = currentNode;\n    do\n    {\n        yield \"$parent\";\n        yield \"$activity\";\n        if (node.userId) {\n            yield node.userId;\n        }\n        yield* node.enumeratePropertyNames(canEnumeratePrivate);\n        canEnumeratePrivate = false;\n\n        if (noWalk) {\n            break;\n        }\n\n        node = node.parent;\n    }\n    while (node);\n};\n/* PROXY */\n\n/* WALK */\nScopeTree.prototype.next = function (nodeInstanceId, childInstanceId, scopePart, childUserId) {\n    let currentNode = this._getNodeByExternalId(nodeInstanceId);\n    let nextNode = new ScopeNode(childInstanceId, scopePart, childUserId);\n    currentNode.addChild(nextNode);\n    this._nodes.set(childInstanceId, nextNode);\n    return scope.create(this, nextNode);\n};\n\nScopeTree.prototype.back = function (nodeId, keepItem) {\n    let currentNode = this._getNodeByExternalId(nodeId);\n    if (currentNode === this._initialNode) {\n        throw new Error(\"Cannot go back because current scope is the initial scope.\");\n    }\n    let toRemove = currentNode;\n    let goTo = toRemove.parent;\n    currentNode = goTo;\n    if (!keepItem) {\n        goTo.removeChild(toRemove);\n        this._nodes.delete(toRemove.instanceId);\n    }\n    return scope.create(this, currentNode);\n};\n\nScopeTree.prototype.find = function (nodeId) {\n    let currentNode = this._getNodeByExternalId(nodeId);\n    return scope.create(this, currentNode);\n};\n\nScopeTree.prototype.findPart = function (nodeId) {\n    let currentNode = this._getNodeByExternalId(nodeId);\n    if (currentNode !== this._initialNode) {\n        return currentNode.scopePart;\n    }\n    return null;\n};\n/* WALK */\n\nScopeTree.prototype._getNodeByExternalId = function (id) {\n    if (id === null) {\n        return this._initialNode;\n    }\n    let node = this._nodes.get(id);\n    if (!node) {\n        throw new Error(\"Scope node for activity id '\" + id + \"' is not found.\");\n    }\n    return node;\n};\n\nScopeTree.prototype.deleteScopePart = function (currentNodeId, id) {\n    let self = this;\n    let currentNode = this._getNodeByExternalId(currentNodeId);\n    let delNode = self._nodes.get(id);\n    if (delNode) {\n        if (delNode === self._initialNode) {\n            throw new Error(\"Cannot delete the initial scope.\");\n        }\n        let found = false;\n        for (let node of delNode.walkToRoot()) {\n            if (node === currentNode) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new Error(\"Cannot delete scope, because current active scope is inside in it.\");\n        }\n        delNode.parent.removeChild(delNode);\n        self._removeAllNodes(delNode);\n    }\n};\n\nScopeTree.prototype._removeAllNodes = function (node) {\n    let self = this;\n\n    self._nodes.delete(node.instanceId);\n    for (let c of node.children()) {\n        self._removeAllNodes(c);\n    }\n};\n\nmodule.exports = ScopeTree;"],"file":"activities/scopeTree.js","sourceRoot":"/source/"}