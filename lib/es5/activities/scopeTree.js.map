{"version":3,"names":[],"mappings":"","sources":["activities/scopeTree.js"],"sourcesContent":["\"use strict\";\r\n\r\nlet ScopeNode = require(\"./scopeNode\");\r\nlet constants = require(\"../common/constants\");\r\nlet _ = require(\"lodash\");\r\nlet specStrings = require(\"../common/specStrings\");\r\nlet errors = require(\"../common/errors\");\r\nlet is = require(\"../common/is\");\r\nlet scope = require(\"./scope\");\r\nlet Expression = require(\"./expression\");\r\nlet scopeSerializer = require(\"./scopeSerializer\");\r\n\r\nfunction ScopeTree(initialScope, getActivityByIdFunc) {\r\n    this._initialNode = new ScopeNode(constants.ids.initialScope, initialScope);\r\n    this._nodes = new Map();\r\n    this._nodes.set(this._initialNode.instanceId, this._initialNode);\r\n    this._getActivityById = getActivityByIdFunc;\r\n}\r\n\r\n/* SERIALIZATION */\r\nScopeTree.prototype.getExecutionState = function (execContext, enablePromotions, serializer) {\r\n    return scopeSerializer.serialize(execContext, this._getActivityById, enablePromotions, this._nodes.values(), serializer);\r\n};\r\n\r\nScopeTree.prototype.setState = function (json, serializer) {\r\n    if (!_.isArray(json)) {\r\n        throw new TypeError(\"Array argument expected.\");\r\n    }\r\n\r\n    if (this._nodes.count !== 1) {\r\n        let prev = this._nodes;\r\n        this._nodes = new Map();\r\n        this._nodes.set(constants.ids.initialScope, prev.get(constants.ids.initialScope));\r\n        this._initialNode.clearChildren();\r\n    }\r\n\r\n    try {\r\n        // Create nodes:\r\n        for (let node of scopeSerializer.deserializeNodes(this._getActivityById, json, serializer)) {\r\n            this._nodes.set(node.instanceId, node);\r\n        }\r\n        // Setup Tree:\r\n        for (let item of json) {\r\n            this._nodes.get(item.instanceId).parent = this._nodes.get(item.parentId);\r\n        }\r\n        // Setup specials:\r\n        for (let node of this._nodes.values()) {\r\n            for (let key of node._keys) {\r\n                let value = node.scopePart[key];\r\n                if (value && value.$type === constants.markers.$parent) {\r\n                    let parentScope = scope.create(this, this._nodes.get(value.id), true);\r\n                    parentScope.__marker = constants.markers.$parent;\r\n                    node.scopePart[key] = parentScope;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        throw new errors.WorkflowError(\"Cannot restore state tree, because data is corrupt. Inner error: \" + e.stack);\r\n    }\r\n};\r\n/* SERIALIZATION */\r\n\r\n/* PROXY */\r\n\r\nScopeTree.prototype._getRealParent = function (currentNode) {\r\n    let parent = currentNode.parent;\r\n    if (currentNode.activity instanceof Expression) {\r\n        parent = parent.parent;\r\n    }\r\n    return parent;\r\n};\r\n\r\nScopeTree.prototype.hasProperty = function (currentNode, name) {\r\n    if (name === \"$parent\") {\r\n        let parent = this._getRealParent(currentNode);\r\n        if (parent && parent !== this._initialNode) {\r\n            return !!parent;\r\n        }\r\n    }\r\n\r\n    if (name === \"$activity\") {\r\n        return true;\r\n    }\r\n\r\n    let found = false;\r\n    for (let node of currentNode.walkToRoot()) {\r\n        if (node.isPropertyExists(name)) {\r\n            found = true;\r\n            break;\r\n        }\r\n        if (node.userId === name) {\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n    return found;\r\n};\r\n\r\nScopeTree.prototype.getValue = function (currentNode, name) {\r\n    let self = this;\r\n\r\n    if (name === \"$parent\") {\r\n        let parent = this._getRealParent(currentNode);\r\n        if (parent && parent !== this._initialNode) {\r\n            let parentScope = scope.create(this, parent);\r\n            parentScope.__marker = constants.markers.$parent;\r\n            return parentScope;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    if (name === \"$activity\") {\r\n        return currentNode.activity;\r\n    }\r\n\r\n    let canReturnPrivate = true;\r\n    let value;\r\n    for (let node of currentNode.walkToRoot()) {\r\n        if (!_.isUndefined(value = node.getPropertyValue(name, canReturnPrivate))) {\r\n            break;\r\n        }\r\n        if (node.userId === name && node !== currentNode) {\r\n            value = scope.create(self, node);\r\n            break;\r\n        }\r\n        canReturnPrivate = false;\r\n    }\r\n    return value;\r\n};\r\n\r\nScopeTree.prototype.setValue = function (currentNode, name, value, noWalk) {\r\n    if (this.isOnInitial) {\r\n        throw new Error(\"Cannot set property of the initial scope.\");\r\n    }\r\n\r\n    let self = this;\r\n    let canSetPrivate = true;\r\n    let setDone = false;\r\n    for (let node of currentNode.walkToRoot(noWalk)) {\r\n        if (node === self._initialNode) {\r\n            break;\r\n        }\r\n        if (node.setPropertyValue(name, value, canSetPrivate)) {\r\n            setDone = true;\r\n            break;\r\n        }\r\n        canSetPrivate = false;\r\n    }\r\n\r\n    if (!setDone) {\r\n        currentNode.createPropertyWithValue(name, value);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nScopeTree.prototype.deleteProperty = function (currentNode, name, noWalk) {\r\n    let self = this;\r\n    let canDeletePrivate = true;\r\n    let deleteDone = false;\r\n    for (let node of currentNode.walkToRoot(noWalk)) {\r\n        if (node === self._initialNode) {\r\n            break;\r\n        }\r\n        if (node.deleteProperty(name, canDeletePrivate)) {\r\n            deleteDone = true;\r\n            break;\r\n        }\r\n        canDeletePrivate = false;\r\n    }\r\n\r\n    return deleteDone;\r\n};\r\n\r\nScopeTree.prototype.enumeratePropertyNames = function* (currentNode, noWalk) {\r\n    let canEnumeratePrivate = true;\r\n    let node = currentNode;\r\n    do\r\n    {\r\n        yield \"$parent\";\r\n        yield \"$activity\";\r\n        if (node.userId) {\r\n            yield node.userId;\r\n        }\r\n        yield* node.enumeratePropertyNames(canEnumeratePrivate);\r\n        canEnumeratePrivate = false;\r\n\r\n        if (noWalk) {\r\n            break;\r\n        }\r\n\r\n        node = node.parent;\r\n    }\r\n    while (node);\r\n};\r\n/* PROXY */\r\n\r\n/* WALK */\r\nScopeTree.prototype.next = function (nodeInstanceId, childInstanceId, scopePart, childUserId) {\r\n    let currentNode = this._getNodeByExternalId(nodeInstanceId);\r\n    let nextNode = new ScopeNode(childInstanceId, scopePart, childUserId, this._getActivityById(childInstanceId));\r\n    currentNode.addChild(nextNode);\r\n    this._nodes.set(childInstanceId, nextNode);\r\n    return scope.create(this, nextNode);\r\n};\r\n\r\nScopeTree.prototype.back = function (nodeId, keepItem) {\r\n    let currentNode = this._getNodeByExternalId(nodeId);\r\n    if (currentNode === this._initialNode) {\r\n        throw new Error(\"Cannot go back because current scope is the initial scope.\");\r\n    }\r\n    let toRemove = currentNode;\r\n    let goTo = toRemove.parent;\r\n    currentNode = goTo;\r\n    if (!keepItem) {\r\n        goTo.removeChild(toRemove);\r\n        this._nodes.delete(toRemove.instanceId);\r\n    }\r\n    return scope.create(this, currentNode);\r\n};\r\n\r\nScopeTree.prototype.find = function (nodeId) {\r\n    let currentNode = this._getNodeByExternalId(nodeId);\r\n    return scope.create(this, currentNode);\r\n};\r\n\r\nScopeTree.prototype.findPart = function (nodeId) {\r\n    let currentNode = this._getNodeByExternalId(nodeId);\r\n    if (currentNode !== this._initialNode) {\r\n        return currentNode.scopePart;\r\n    }\r\n    return null;\r\n};\r\n/* WALK */\r\n\r\nScopeTree.prototype._getNodeByExternalId = function (id) {\r\n    if (id === null) {\r\n        return this._initialNode;\r\n    }\r\n    let node = this._nodes.get(id);\r\n    if (!node) {\r\n        throw new Error(\"Scope node for activity id '\" + id + \"' is not found.\");\r\n    }\r\n    return node;\r\n};\r\n\r\nScopeTree.prototype.deleteScopePart = function (currentNodeId, id) {\r\n    let self = this;\r\n    let currentNode = this._getNodeByExternalId(currentNodeId);\r\n    let delNode = self._nodes.get(id);\r\n    if (delNode) {\r\n        if (delNode === self._initialNode) {\r\n            throw new Error(\"Cannot delete the initial scope.\");\r\n        }\r\n        let found = false;\r\n        for (let node of delNode.walkToRoot()) {\r\n            if (node === currentNode) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            throw new Error(\"Cannot delete scope, because current active scope is inside in it.\");\r\n        }\r\n        delNode.parent.removeChild(delNode);\r\n        self._removeAllNodes(delNode);\r\n    }\r\n};\r\n\r\nScopeTree.prototype._removeAllNodes = function (node) {\r\n    let self = this;\r\n\r\n    self._nodes.delete(node.instanceId);\r\n    for (let c of node.children()) {\r\n        self._removeAllNodes(c);\r\n    }\r\n};\r\n\r\nmodule.exports = ScopeTree;"],"file":"activities/scopeTree.js","sourceRoot":"/source/"}