{"version":3,"names":[],"mappings":"","sources":["hosting/workflowRegistry.js"],"sourcesContent":["\"use strict\";\r\n\r\nlet Workflow = require(\"../activities/workflow\");\r\nlet _ = require(\"lodash\");\r\nlet BeginMethod = require(\"../activities/beginMethod\");\r\nlet EndMethod = require(\"../activities/endMethod\");\r\nlet is = require(\"../common/is\");\r\nlet ActivityExecutionContext = require(\"../activities/activityExecutionContext\");\r\nlet activityMarkup = require(\"../activities/activityMarkup\");\r\nlet Serializer = require(\"backpack-node\").system.Serializer;\r\nlet crypto = require(\"crypto\");\r\nlet assert = require(\"better-assert\");\r\n\r\nfunction WorkflowRegistry(serializer) {\r\n    this._workflows = new Map();\r\n    this._serializer = serializer || new Serializer();\r\n}\r\n\r\nWorkflowRegistry.prototype.register = function (workflow, deprecated) {\r\n    if (_.isPlainObject(workflow)) {\r\n        workflow = activityMarkup.parse(workflow);\r\n    }\r\n    if (workflow instanceof Workflow) {\r\n        if (!_(workflow.name).isString()) {\r\n            throw new TypeError(\"Workflow name is not a string.\");\r\n        }\r\n        let name = workflow.name.trim();\r\n        if (!name) {\r\n            throw new TypeError(\"Workflow name is empty.\");\r\n        }\r\n        let execContext = new ActivityExecutionContext();\r\n        execContext.initialize(workflow);\r\n        let version = this._computeVersion(execContext);\r\n        let entry = this._workflows.get(name);\r\n        let desc;\r\n        if (entry) {\r\n            desc = entry.get(version);\r\n            if (desc) {\r\n                throw new Error(\"Workflow \" + name + \" (\" + version + \") already registered.\");\r\n            }\r\n            else {\r\n                if (!deprecated) {\r\n                    for (desc of entry.values()) {\r\n                        if (!desc.deprecated) {\r\n                            throw new Error(\"Workflow \" + name + \" (\" + version + \") has an already registered undeprecated version.\");\r\n                        }\r\n                    }\r\n                }\r\n                desc = this._createDesc(execContext, name, version, deprecated);\r\n                entry.set(version, desc);\r\n            }\r\n        }\r\n        else {\r\n            entry = new Map();\r\n            desc = this._createDesc(execContext, name, version, deprecated);\r\n            entry.set(version, desc);\r\n            this._workflows.set(name, entry);\r\n        }\r\n        return desc;\r\n    }\r\n    else {\r\n        throw new TypeError(\"Workflow instance argument expected.\");\r\n    }\r\n};\r\n\r\nWorkflowRegistry.prototype.getDesc = function (name, version) {\r\n    let entry = this._workflows.get(name);\r\n    if (entry) {\r\n        if (!_.isUndefined(version)) {\r\n            let desc = entry.get(version);\r\n            if (desc) {\r\n                return desc;\r\n            }\r\n            throw new Error(\"Workflow \" + name + \" of version \" + version + \" has not been registered.\");\r\n        }\r\n        else {\r\n            // Get undeprecated\r\n            let desc = null;\r\n            for (let d of entry.values()) {\r\n                if (!d.deprecated) {\r\n                    desc = d;\r\n                    break;\r\n                }\r\n            }\r\n            if (desc) {\r\n                return desc;\r\n            }\r\n            throw new Error(\"Workflow \" + name + \" hasn't got an undeprecated version registered.\");\r\n        }\r\n    }\r\n};\r\n\r\nWorkflowRegistry.prototype.getCurrentVersion = function (workflowName) {\r\n    let result = [];\r\n    let entry = this._workflows.get(workflowName);\r\n    if (entry) {\r\n        let desc = null;\r\n        for (let d of entry.values()) {\r\n            if (!d.deprecated) {\r\n                desc = d;\r\n                break;\r\n            }\r\n        }\r\n        if (desc) {\r\n            return desc.version;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\nWorkflowRegistry.prototype._createDesc = function (execContext, name, version, deprecated) {\r\n    return {\r\n        execContext: execContext,\r\n        name: name,\r\n        version: version,\r\n        methods: this._collectMethodInfos(execContext, version),\r\n        deprecated: deprecated\r\n    };\r\n};\r\n\r\nWorkflowRegistry.prototype._collectMethodInfos = function (execContext, version) {\r\n    let self = this;\r\n    let infos = new Map();\r\n    let workflow = execContext.rootActivity;\r\n    for (let child of workflow.children(execContext)) {\r\n        let isBM = child instanceof BeginMethod;\r\n        let isEM = child instanceof EndMethod;\r\n        if (isBM || isEM) {\r\n            let methodName = _.isString(child.methodName) ? child.methodName.trim() : null;\r\n            let instanceIdPath = _.isString(child.instanceIdPath) ? child.instanceIdPath.trim() : null;\r\n            if (methodName) {\r\n                let info = infos.get(methodName);\r\n                if (!info) {\r\n                    info = {\r\n                        execContext: execContext,\r\n                        version: version,\r\n                        canCreateInstance: false,\r\n                        instanceIdPath: null\r\n                    };\r\n                    infos.set(methodName, info);\r\n                }\r\n                if (isBM && child.canCreateInstance) {\r\n                    info.canCreateInstance = true;\r\n                }\r\n                if (instanceIdPath) {\r\n                    if (info.instanceIdPath) {\r\n                        if (info.instanceIdPath !== instanceIdPath) {\r\n                            throw new Error(\"Method '\" + methodName + \"' in workflow '\" + workflow.name + \"' has multiple different instanceIdPath value which is not supported.\");\r\n                        }\r\n                    }\r\n                    else {\r\n                        info.instanceIdPath = instanceIdPath;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    let result = new Map();\r\n    for (let kvp of infos.entries()) {\r\n        if (kvp[1].instanceIdPath) {\r\n            result.set(kvp[0], kvp[1]);\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nWorkflowRegistry.prototype.methodInfos = function* (workflowName, methodName) {\r\n    let entry = this._workflows.get(workflowName);\r\n    if (entry) {\r\n        for (let desc of entry.values()) {\r\n            let info = desc.methods.get(methodName);\r\n            if (info) {\r\n                yield info;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nWorkflowRegistry.prototype._computeVersion = function(execContext) {\r\n    let self = this;\r\n    let workflow = execContext.rootActivity;\r\n    let sha = crypto.createHash(\"sha256\");\r\n    function add(value) {\r\n        if (!_.isNull(value)) {\r\n            value = self._serializer.stringify(value);\r\n            sha.update(value);\r\n        }\r\n    }\r\n    for (let activity of workflow.all(execContext)) {\r\n        let alias = activityMarkup.getAlias(activity);\r\n        assert(alias);\r\n        add(alias);\r\n        for (let key in activity) {\r\n            if (activity.hasOwnProperty(key) &&\r\n                !activity.nonScopedProperties.has(key) &&\r\n                !activity.nonSerializedProperties.has(key)) {\r\n                let value = activity[key];\r\n                if (!is.activity(value)) {\r\n                    if (_.isArray(value)) {\r\n                        for (let item of value) {\r\n                            if (!is.activity(item)) {\r\n                                add(value);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        add(value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return sha.digest(\"hex\");\r\n};\r\n\r\nmodule.exports = WorkflowRegistry;\r\n"],"file":"hosting/workflowRegistry.js","sourceRoot":"/source/"}