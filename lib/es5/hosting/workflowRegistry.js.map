{"version":3,"names":[],"mappings":"","sources":["hosting/workflowRegistry.js"],"sourcesContent":["\"use strict\";\n\nlet Workflow = require(\"../activities/workflow\");\nlet _ = require(\"lodash\");\nlet BeginMethod = require(\"../activities/beginMethod\");\nlet EndMethod = require(\"../activities/endMethod\");\nlet is = require(\"../common/is\");\nlet ActivityExecutionContext = require(\"../activities/activityExecutionContext\");\nlet activityMarkup = require(\"../activities/activityMarkup\");\nlet Serializer = require(\"backpack-node\").system.Serializer;\nlet crypto = require(\"crypto\");\nlet assert = require(\"better-assert\");\n\nfunction WorkflowRegistry(serializer) {\n    this._workflows = new Map();\n    this._serializer = serializer || new Serializer();\n}\n\nWorkflowRegistry.prototype.register = function (workflow, deprecated) {\n    if (_.isPlainObject(workflow)) {\n        workflow = activityMarkup.parse(workflow);\n    }\n    if (workflow instanceof Workflow) {\n        if (!_(workflow.name).isString()) {\n            throw new TypeError(\"Workflow name is not a string.\");\n        }\n        let name = workflow.name.trim();\n        if (!name) {\n            throw new TypeError(\"Workflow name is empty.\");\n        }\n        let execContext = new ActivityExecutionContext();\n        execContext.initialize(workflow);\n        let version = this._computeVersion(execContext, workflow);\n        let entry = this._workflows.get(name);\n        let desc;\n        if (entry) {\n            desc = entry.get(version);\n            if (desc) {\n                throw new Error(\"Workflow \" + name + \" (\" + version + \") already registered.\");\n            }\n            else {\n                if (!deprecated) {\n                    for (desc of entry.values()) {\n                        if (!desc.deprecated) {\n                            throw new Error(\"Workflow \" + name + \" (\" + version + \") has an already registered undeprecated version.\");\n                        }\n                    }\n                }\n                desc = this._createDesc(execContext, workflow, name, version, deprecated);\n                entry.set(version, desc);\n            }\n        }\n        else {\n            entry = new Map();\n            desc = this._createDesc(execContext, workflow, name, version, deprecated);\n            entry.set(version, desc);\n            this._workflows.set(name, entry);\n        }\n        return desc;\n    }\n    else {\n        throw new TypeError(\"Workflow instance argument expected.\");\n    }\n};\n\nWorkflowRegistry.prototype.getDesc = function (name, version) {\n    let entry = this._workflows.get(name);\n    if (entry) {\n        if (!_.isUndefined(version)) {\n            let desc = entry.get(version);\n            if (desc) {\n                return desc;\n            }\n            throw new Error(\"Workflow \" + name + \" of version \" + version + \" has not been registered.\");\n        }\n        else {\n            // Get undeprecated\n            let desc = null;\n            for (let d of entry.values()) {\n                if (!d.deprecated) {\n                    desc = d;\n                    break;\n                }\n            }\n            if (desc) {\n                return desc;\n            }\n            throw new Error(\"Workflow \" + name + \" hasn't got an undeprecated version registered.\");\n        }\n    }\n};\n\nWorkflowRegistry.prototype.getCurrentVersion = function (workflowName) {\n    let result = [];\n    let entry = this._workflows.get(workflowName);\n    if (entry) {\n        let desc = null;\n        for (let d of entry.values()) {\n            if (!d.deprecated) {\n                desc = d;\n                break;\n            }\n        }\n        if (desc) {\n            return desc.version;\n        }\n    }\n    return null;\n};\n\nWorkflowRegistry.prototype._createDesc = function (execContext, workflow, name, version, deprecated) {\n    return {\n        workflow: workflow,\n        name: name,\n        version: version,\n        methods: this._collectMethodInfos(execContext, workflow, version),\n        deprecated: deprecated\n    };\n};\n\nWorkflowRegistry.prototype._collectMethodInfos = function (execContext, workflow, version) {\n    let self = this;\n    let infos = new Map();\n    for (let child of workflow.children(execContext)) {\n        let isBM = child instanceof BeginMethod;\n        let isEM = child instanceof EndMethod;\n        if (isBM || isEM) {\n            let methodName = _.isString(child.methodName) ? child.methodName.trim() : null;\n            let instanceIdPath = _.isString(child.instanceIdPath) ? child.instanceIdPath.trim() : null;\n            if (methodName) {\n                let info = infos.get(methodName);\n                if (!info) {\n                    info = {\n                        workflow: workflow,\n                        version: version,\n                        canCreateInstance: false,\n                        instanceIdPath: null\n                    };\n                    infos.set(methodName, info);\n                }\n                if (isBM && child.canCreateInstance) {\n                    info.canCreateInstance = true;\n                }\n                if (instanceIdPath) {\n                    if (info.instanceIdPath) {\n                        if (info.instanceIdPath !== instanceIdPath) {\n                            throw new Error(\"Method '\" + methodName + \"' in workflow '\" + workflow.name + \"' has multiple different instanceIdPath value which is not supported.\");\n                        }\n                    }\n                    else {\n                        info.instanceIdPath = instanceIdPath;\n                    }\n                }\n            }\n        }\n    }\n    let result = new Map();\n    for (let kvp of infos.entries()) {\n        if (kvp[1].instanceIdPath) {\n            result.set(kvp[0], kvp[1]);\n        }\n    }\n    return result;\n};\n\nWorkflowRegistry.prototype.methodInfos = function* (workflowName, methodName) {\n    let entry = this._workflows.get(workflowName);\n    if (entry) {\n        for (let desc of entry.values()) {\n            let info = desc.methods.get(methodName);\n            if (info) {\n                yield info;\n            }\n        }\n    }\n};\n\nWorkflowRegistry.prototype._computeVersion = function(execContext, workflow) {\n    let self = this;\n    let sha = crypto.createHash(\"sha256\");\n    function add(value) {\n        if (!_.isNull(value)) {\n            value = self._serializer.stringify(value);\n            sha.update(value);\n        }\n    }\n    for (let activity of workflow.all(execContext)) {\n        let alias = activityMarkup.getAlias(activity);\n        assert(alias);\n        add(alias);\n        for (let key in activity) {\n            if (activity.hasOwnProperty(key) &&\n                !activity.nonScopedProperties.has(key) &&\n                !activity.nonSerializedProperties.has(key)) {\n                let value = activity[key];\n                if (!is.activity(value)) {\n                    if (_.isArray(value)) {\n                        for (let item of value) {\n                            if (!is.activity(item)) {\n                                add(value);\n                            }\n                        }\n                    }\n                    else {\n                        add(value);\n                    }\n                }\n            }\n        }\n    }\n    return sha.digest(\"base64\");\n};\n\nmodule.exports = WorkflowRegistry;\n"],"file":"hosting/workflowRegistry.js","sourceRoot":"/source/"}