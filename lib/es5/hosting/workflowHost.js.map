{"version":3,"names":[],"mappings":"","sources":["hosting/workflowHost.js"],"sourcesContent":["\"use strict\";\n\nlet WorkflowRegistry = require(\"./workflowRegistry\");\nlet _ = require(\"lodash\");\nlet Activity = require(\"../activities/activity\");\nlet Workflow = require(\"../activities/workflow\");\nlet WorkflowPersistence = require(\"./workflowPersistence\");\nlet WorkflowInstance = require(\"./workflowInstance\");\nlet InstanceIdParser = require(\"./instanceIdParser\");\nlet enums = require(\"../common/enums\");\nlet Bluebird = require(\"bluebird\");\nlet KnownInstaStore = require(\"./knownInstaStore\");\nlet specStrings = require(\"../common/specStrings\");\nlet errors = require(\"../common/errors\");\nlet Serializer = require(\"backpack-node\").system.Serializer;\nlet is = require(\"../common/is\");\nlet KeepLockAlive = require(\"./keepLockAlive\");\nlet asyncHelpers = require(\"../common/asyncHelpers\");\nlet async = asyncHelpers.async;\nlet WakeUp = require(\"./wakeUp\");\nlet assert = require(\"assert\");\nlet debug = require(\"debug\")(\"wf4node:WorkflowHost\");\nlet EventEmitter = require(\"events\").EventEmitter;\nlet util = require(\"util\");\n\nfunction WorkflowHost(options) {\n    EventEmitter.call(this);\n\n    this._options = _.extend(\n        {\n            enterLockTimeout: 10000,\n            lockRenewalTimeout: 5000,\n            alwaysLoadState: false,\n            lazyPersistence: true,\n            persistence: null,\n            serializer: null,\n            enablePromotions: false,\n            wakeUpOptions: {\n                interval: 5000,\n                batchSize: 10\n            }\n        },\n        options);\n\n    this._registry = new WorkflowRegistry(this._options.serializer);\n    this._trackers = [];\n    this._isInitialized = false;\n    this._instanceIdParser = new InstanceIdParser();\n    this._persistence = null;\n\n    if (this._options.persistence !== null) {\n        this._persistence = new WorkflowPersistence(this._options.persistence);\n    }\n    this._knownRunningInstances = new KnownInstaStore();\n    this._wakeUp = null;\n    this._shutdown = false;\n}\n\nutil.inherits(WorkflowHost, EventEmitter);\n\nWorkflowHost.events = enums.workflowEvents;\n\nWorkflowHost.prototype.onWorkflowEvent = function (args) {\n    this.emit(WorkflowHost.events.workflowEvent, args);\n};\n\nWorkflowHost.prototype.onWarn = function (error) {\n    this.emit(WorkflowHost.events.warn, error);\n};\n\nWorkflowHost.prototype.onStart = function (instance, methodName, args) {\n    this.emit(WorkflowHost.events.start, {\n        instance: instance,\n        methodName: methodName,\n        args: args\n    });\n};\n\nWorkflowHost.prototype.onInvoke = function (instance, methodName, args, result, idle, error) {\n    this.emit(WorkflowHost.events.invoke, {\n        instance: instance,\n        methodName: methodName,\n        args: args,\n        idle: idle,\n        error: error\n    });\n};\n\nWorkflowHost.prototype.onEnd = function (instance, result, cancelled, error) {\n    this.emit(WorkflowHost.events.end, {\n        instance: instance,\n        result: result,\n        cancelled: cancelled,\n        error: error\n    });\n};\n\nObject.defineProperties(\n    WorkflowHost.prototype, {\n        options: {\n            get: function () {\n                return this._options;\n            }\n        },\n        isInitialized: {\n            get: function () {\n                return this._isInitialized;\n            }\n        },\n        instanceIdParser: {\n            get: function () {\n                return this._instanceIdParser;\n            }\n        },\n        persistence: {\n            get: function () {\n                return this._persistence;\n            }\n        },\n        _inLockTimeout: {\n            get: function () {\n                return this.options.lockRenewalTimeout + Math.max(this.options.lockRenewalTimeout * 0.4, 3000);\n            }\n        }\n    });\n\nWorkflowHost.prototype.registerDeprecatedWorkflow = function (workflow) {\n    return this.registerWorkflow(workflow, true);\n};\n\nWorkflowHost.prototype.registerWorkflow = function (workflow, deprecated) {\n    this._verify();\n    let desc = this._registry.register(workflow, deprecated);\n    debug(\"Workflow registered. name: %s, version: %s\", desc.name, desc.version);\n    return desc.version;\n};\n\nWorkflowHost.prototype._initialize = function () {\n    let self = this;\n    if (!this._isInitialized) {\n        if (this._options.wakeUpOptions && this._options.wakeUpOptions.interval > 0) {\n            this._wakeUp = new WakeUp(this._knownRunningInstances, this._persistence, this._options.wakeUpOptions);\n            this._wakeUp.on(\"continue\", function (i) { self._continueWokeUpInstance(i); });\n            this._wakeUp.on(\"error\", function (e) { self.onWarn(e); });\n            this._wakeUp.start();\n        }\n\n        this._isInitialized = true;\n    }\n};\n\nWorkflowHost.prototype.stop = async(function*(workflowName, instanceId) {\n    let self = this;\n    let remove = function (instanceId) {\n        let knownInsta = self._knownRunningInstances.get(workflowName, instanceId);\n        if (knownInsta) {\n            debug(\"Removing instance: %s\", instanceId);\n            self._deleteWFInstance(knownInsta);\n            self.onEnd(knownInsta, undefined, true);\n        }\n    };\n\n    debug(\"Stopping workflow '%s' with id: '%s'.\", workflowName, instanceId);\n\n    try {\n        if (this._persistence) {\n            let lockName = specStrings.hosting.doubleKeys(workflowName, instanceId);\n            let lockInfo;\n            debug(\"Locking instance: %s\", instanceId);\n            lockInfo = yield (this._persistence.enterLock(lockName, this.options.enterLockTimeout, this._inLockTimeout));\n            let keepLockAlive = null;\n            try {\n                debug(\"Locked: %j\", lockInfo);\n                keepLockAlive = new KeepLockAlive(this._persistence, lockInfo, this._inLockTimeout, this.options.lockRenewalTimeout);\n\n                // Do stuff:\n                yield this._persistence.removeState(workflowName, instanceId, false, \"STOPPED.\");\n                remove(instanceId);\n\n                debug(\"Removed: %s\", instanceId);\n            }\n            catch (e) {\n                debug(\"Error: %s\", e.stack);\n                throw e;\n            }\n            finally {\n                // Unlock:\n                debug(\"Unlocking.\");\n                if (keepLockAlive) {\n                    keepLockAlive.end();\n                }\n                yield this._persistence.exitLock(lockInfo.id);\n            }\n        }\n        else {\n            remove(instanceId);\n        }\n    }\n    catch (e) {\n        debug(\"Error: %s\", e.stack);\n        throw new errors.WorkflowError(`Cannot stop instance of workflow '${workflowName}' with id: '${instanceId}' because of an internal error:\\n${e.stack}`);\n    }\n});\n\nWorkflowHost.prototype.stopDeprecatedVersions = async(function* (workflowName) {\n    this._verify();\n    debug(\"Stopping outdated versions of workflow '%s'.\", workflowName);\n\n\n\n    let count = 0;\n    let currentVersion = this._registry.getCurrentVersion(workflowName);\n    if (currentVersion) {\n        let oldVersionHeaders = yield this._getRunningInstanceHeadersForOtherVersion(workflowName, currentVersion);\n        if (oldVersionHeaders.length) {\n            debug(\"There is %d old version running. Stopping them.\", oldVersionHeaders.length);\n            for (let header of oldVersionHeaders) {\n                debug(\"Stopping workflow '%s' of version '%s' with id: '%s'.\", header.workflowName, header.workflowVersion, header.instanceId);\n                yield this.stop(workflowName, header.instanceId);\n            }\n        }\n    }\n    else {\n        debug(\"There is no workflow registered by name '%s'.\", workflowName);\n    }\n    return count;\n});\n\nWorkflowHost.prototype.invokeMethod = async(function* (workflowName, methodName, args) {\n    this._verify();\n    debug(\"Invoking method: '%s' of workflow: '%s' by arguments '%j'\", workflowName, methodName, args);\n\n    if (!_(workflowName).isString()) {\n        throw new TypeError(\"Argument 'workflowName' is not a string.\");\n    }\n    workflowName = workflowName.trim();\n    if (!_(methodName).isString()) {\n        throw new TypeError(\"Argument 'methodName' is not a string.\");\n    }\n    methodName = methodName.trim();\n\n    if (!_.isUndefined(args) && !_.isArray(args)) {\n        args = [args];\n    }\n\n    let self = this;\n\n    self._initialize();\n\n    let instanceId = null;\n    let creatable = null;\n\n    let results = [];\n    for (let info of self._registry.methodInfos(workflowName, methodName)) {\n        let tryId = self._instanceIdParser.parse(info.instanceIdPath, args);\n        if (!_.isUndefined(tryId)) {\n            results.push(\n                {\n                    info: info,\n                    id: tryId\n                });\n        }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n        debug(\"Possible methods: %j\",\n            _(results)\n                .map(function (r) {\n                    return {\n                        workflow: {\n                            name: r.info.execContext.rootActivity.name,\n                            version: r.info.version\n                        },\n                        id: r.id\n                    };\n                })\n                .toArray());\n    }\n\n    for (let i = 0; i < results.length; i++) {\n        let result = results[i];\n        // That finds the latest version:\n        if (result.info.canCreateInstance && !result.info.deprecated) {\n            creatable = result.info;\n        }\n        // That finds a running instance with the id:\n        if (_.isNull(instanceId) && (yield self._checkIfInstanceRunning(workflowName, result.id))) {\n            instanceId = result.id;\n            break;\n        }\n    }\n\n    if (instanceId) {\n        debug(\"Found a continuable instance id: %s. Invoking method on that.\", instanceId);\n        try {\n            let ir = yield (self._invokeMethodOnRunningInstance(instanceId, workflowName, methodName, args));\n            debug(\"Invoke completed, result: %j\", ir);\n            return ir;\n        }\n        catch (e) {\n            debug(\"Invoke failed: %s\", e.stack);\n            throw e;\n        }\n    }\n    else if (creatable) {\n        debug(\"Found a creatable workflow (name: '%s', version: '%s'), invoking a create method on that.\", creatable.execContext.rootActivity.name, creatable.version);\n        try {\n            let cr = yield (self._createInstanceAndInvokeMethod(creatable.execContext, creatable.version, methodName, args));\n            debug(\"Create completed, result: %j\", cr);\n            return cr;\n        }\n        catch (e) {\n            debug(\"Create failed: %s\", e.stack);\n            throw e;\n        }\n    }\n    else {\n        debug(\"No continuable workflows have been found.\");\n        throw new errors.MethodNotFoundError(\"Cannot create or continue workflow '\" + workflowName + \"' by calling method '\" + methodName + \"'.\");\n    }\n});\n\nWorkflowHost.prototype._createInstanceAndInvokeMethod = async(function* (execContext, workflowVersion, methodName, args) {\n    let workflowName = execContext.rootActivity.name;\n\n    let lockInfo = null;\n\n    if (!this._persistence) {\n        let insta = this._createWFInstance();\n        let result = yield (insta.create(execContext, workflowVersion, methodName, args, lockInfo));\n        this._knownRunningInstances.add(workflowName, insta);\n        this.onStart(insta, methodName, args);\n        return result;\n    }\n    else {\n        lockInfo = {\n            id: null,\n            name: null,\n            heldTo: null\n        };\n        // When lock will held, then we should keep it alive:\n        let keepLockAlive = new KeepLockAlive(this._persistence, lockInfo, this._inLockTimeout, this.options.lockRenewalTimeout);\n        try {\n            let insta = this._createWFInstance();\n            let result = yield (insta.create(execContext, workflowVersion, methodName, args, lockInfo));\n\n            if (insta.execState === enums.activityStates.idle) {\n                this._knownRunningInstances.add(workflowName, insta);\n\n                // Persist and unlock:\n                let err = null;\n                try {\n                    yield this._persistence.persistState(insta);\n                    this.onStart(insta, methodName, args);\n                }\n                catch (e) {\n                    debug(\"Cannot persist instance of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                    this._knownRunningInstances.remove(workflowName, insta.id);\n                    err = e;\n                }\n                try {\n                    yield this._persistence.exitLock(lockInfo.id);\n                }\n                catch (e) {\n                    debug(\"Cannot exit lock of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                    this.onWarn(e);\n                }\n                if (err) {\n                    throw err;\n                }\n\n                return result;\n            }\n            else {\n                return result;\n            }\n        }\n        finally {\n            keepLockAlive.end();\n        }\n    }\n});\n\nWorkflowHost.prototype._throwIfRecoverable = function (error, workflowName, methodName) {\n    if (error instanceof errors.MethodIsNotAccessibleError) {\n        debug(\"Method '%s' of workflow '%s' is not accessible at the current state, bacause it might be stepped on another instance to another state tha is exists at current in this host. Client should retry.\", methodName, workflowName);\n        throw error;\n    }\n};\n\nWorkflowHost.prototype._invokeMethodOnRunningInstance = async(function* (instanceId, workflowName, methodName, args) {\n    let self = this;\n\n    if (!self._persistence) {\n        let insta = yield (self._verifyAndRestoreInstanceState(instanceId, workflowName, methodName, args));\n        try {\n            let result = yield (insta.callMethod(methodName, args));\n            if (insta.execState === enums.activityStates.idle) {\n                this.onInvoke(insta, methodName, args, result, true, null);\n                return result;\n            }\n            else if (insta.execState === enums.activityStates.complete) {\n                self._deleteWFInstance(insta);\n                this.onInvoke(insta, methodName, args, result, false, null);\n                this.onEnd(insta, result, false, null);\n                return result;\n            }\n            else {\n                throw new errors.WorkflowError(\"Instance '\" + insta.id + \"' is in an invalid state '\" + insta.execState + \"' after invocation of the method '\" + methodName + \"'.\");\n            }\n        }\n        catch (e) {\n            this._throwIfRecoverable(e, workflowName, methodName);\n            self._deleteWFInstance(insta);\n            this.onInvoke(insta, methodName, args, undefined, false, e);\n            this.onEnd(insta, undefined, false, e);\n            throw e;\n        }\n    }\n    else {\n        // Lock it:\n        let lockName = specStrings.hosting.doubleKeys(workflowName, instanceId);\n        let lockInfo;\n        let keepLockAlive = null;\n        try {\n            debug(\"Locking instance.\");\n            lockInfo = yield (self._persistence.enterLock(lockName, self.options.enterLockTimeout, self._inLockTimeout));\n            debug(\"Locked: %j\", lockInfo);\n\n            // When lock will held, then we should keep it alive:\n            keepLockAlive = new KeepLockAlive(self._persistence, lockInfo, self._inLockTimeout, self.options.lockRenewalTimeout);\n\n            // LOCKED\n            let insta = yield (self._verifyAndRestoreInstanceState(instanceId, workflowName, methodName, args));\n            let endWithError = async(function*(e) {\n                self._deleteWFInstance(insta);\n                try {\n                    yield (self._persistence.removeState(workflowName, insta.id, false, e));\n                }\n                catch (removeE) {\n                    debug(\"Cannot remove state of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + removeE.stack);\n                    self.onWarn(removeE);\n                }\n                self.onInvoke(insta, methodName, args, undefined, false, e);\n                self.onEnd(insta, undefined, false, e);\n            });\n            try {\n                let persistAndUnlock = function () {\n                    return self._persistence.persistState(insta)\n                        .finally(function () {\n                            debug(\"Unlocking: %j\", lockInfo);\n                            return self._persistence.exitLock(lockInfo.id)\n                                .then(function () {\n                                    debug(\"Unlocked.\");\n                                },\n                                function (e) {\n                                    debug(\"Cannot exit lock for workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                                    self.onWarn(e);\n                                })\n                                .finally(function () {\n                                    keepLockAlive.end();\n                                });\n                        });\n                };\n                let result = yield (insta.callMethod(methodName, args));\n                if (insta.execState === enums.activityStates.idle) {\n                    // Persist and unlock:\n                    if (self.options.lazyPersistence) {\n                        setImmediate(function () {\n                            persistAndUnlock()\n                                .then(function () {\n                                    self.onInvoke(insta, methodName, args, result, true, null);\n                                },\n                                function(e) {\n                                    endWithError(e);\n                                });\n                        });\n                    }\n                    else {\n                        yield persistAndUnlock();\n                        this.onInvoke(insta, methodName, args, result, true, null);\n                    }\n\n                    return result;\n                }\n                else if (insta.execState === enums.activityStates.complete) {\n                    self._deleteWFInstance(insta);\n                    this.onInvoke(insta, methodName, args, result, false, null);\n                    this.onEnd(insta, result, false, null);\n                    try {\n                        try {\n                            yield self._persistence.removeState(workflowName, insta.id, true);\n                        }\n                        catch (e) {\n                            debug(\"Cannot remove state of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                            this.onWarn(e);\n                        }\n\n                        try {\n                            yield self._persistence.exitLock(lockInfo.id);\n                        }\n                        catch (e) {\n                            debug(\"Cannot exit lock of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\n                            this.onWarn(e);\n                        }\n                    }\n                    finally {\n                        keepLockAlive.end();\n                    }\n                    return result;\n                }\n                else {\n                    throw new errors.WorkflowError(\"Instance '\" + insta.id + \"' is in an invalid state '\" + insta.execState + \"' after invocation of the method '\" + methodName + \"'.\");\n                }\n            }\n            catch (e) {\n                this._throwIfRecoverable(e, workflowName, methodName);\n                yield endWithError(e);\n                throw e;\n            }\n        }\n        catch (e) {\n            if (keepLockAlive) {\n                keepLockAlive.end();\n            }\n            if (lockInfo) {\n                try {\n                    yield self._persistence.exitLock(lockInfo.id);\n                }\n                catch (exitE) {\n                    debug(\"Cannot exit lock '\" + lockInfo.id + \"':\\n\" + exitE.stack);\n                    this.onWarn(exitE);\n                }\n            }\n            if (e instanceof errors.TimeoutError) {\n                let msg = \"Cannot call method of workflow '\" + workflowName + \"', because '\" + methodName + \"' is locked.\";\n                debug(msg);\n                throw new errors.MethodIsNotAccessibleError(msg);\n            }\n            throw e;\n        }\n    }\n});\n\nWorkflowHost.prototype._enterLockForCreatedInstance = async(function* (insta, lockInfo) {\n    let li = yield (this._persistence.enterLock(specStrings.hosting.doubleKeys(insta.workflowName, insta.id), this.options.enterLockTimeout, this._getInLockTimeout()));\n    if (yield (this._persistence.isRunning(insta.workflowName, insta.id))) {\n        throw new errors.WorkflowError(\"Cannot create instance of workflow '\" + insta.workflowName + \"' by id '\" + insta.id + \"' because it's already exists.\");\n    }\n    lockInfo.id = li.id;\n    lockInfo.name = li.name;\n    lockInfo.heldTo = li.heldTo;\n});\n\nWorkflowHost.prototype._getInLockTimeout = function () {\n    return this.options.lockRenewalTimeout + Math.max(this.options.lockRenewalTimeout * 0.4, 3000);\n};\n\nWorkflowHost.prototype._verifyAndRestoreInstanceState = async(function* (instanceId, workflowName, methodName, args) {\n    let self = this;\n    let insta = null;\n    if (self._persistence) {\n        let header = yield (self._persistence.getRunningInstanceIdHeader(workflowName, instanceId));\n        if (header) {\n            insta = yield (self._restoreInstanceState(instanceId, workflowName, header.workflowVersion, header.updatedOn));\n        }\n    }\n    else {\n        insta = self._knownRunningInstances.get(workflowName, instanceId);\n    }\n    if (!insta) {\n        throw new errors.WorkflowNotFoundError(`Worflow (name: '${workflowName}', id: '${instanceId}') has been deleted since the lock has been taken.`);\n    }\n\n    return insta;\n});\n\nWorkflowHost.prototype._restoreInstanceState = async(function* (instanceId, workflowName, workflowVersion, actualTimestamp) {\n    let self = this;\n\n    if (!self._persistence) {\n        throw new Error(\"Cannot restore instance from persistence, because host has no persistence registered.\");\n    }\n\n    let insta = self._knownRunningInstances.get(workflowName, instanceId);\n    if (_.isUndefined(insta)) {\n        let wfDesc = self._registry.getDesc(workflowName, workflowVersion);\n        insta = self._createWFInstance();\n        insta.setWorkflow(wfDesc.execContext, workflowVersion, instanceId);\n    }\n\n    if (insta.updatedOn === null || insta.updatedOn.getTime() !== actualTimestamp.getTime() || self.options.alwaysLoadState) {\n        let state = yield (self._persistence.loadState(workflowName, instanceId));\n        insta.restoreState(state);\n        return insta;\n    }\n    else {\n        return insta;\n    }\n});\n\nWorkflowHost.prototype._checkIfInstanceRunning = async(function* (workflowName, instanceId) {\n    if (this._persistence) {\n        return (yield this._persistence.isRunning(workflowName, instanceId));\n    }\n    return this._knownRunningInstances.exists(workflowName, instanceId);\n});\n\nWorkflowHost.prototype._getRunningInstanceHeadersForOtherVersion = async(function* (workflowName, version) {\n    if (this._persistence) {\n        return (yield this._persistence.getRunningInstanceHeadersForOtherVersion(workflowName, version));\n    }\n    return this._knownRunningInstances.getRunningInstanceHeadersForOtherVersion(workflowName, version);\n});\n\nWorkflowHost.prototype.addTracker = function (tracker) {\n    this._verify();\n\n    if (!_.isObject(tracker)) {\n        throw new TypeError(\"Argument is not an object.\");\n    }\n    this._trackers.push(tracker);\n    this._knownRunningInstances.addTracker(tracker);\n};\n\n/* Wake Up*/\n\nWorkflowHost.prototype._continueWokeUpInstance = async(function*(wakeupable) {\n    if (this._shutdown) {\n        wakeupable.result.resolve();\n        return;\n    }\n    if (!this._persistence) {\n        wakeupable.result.reject(new errors.WorkflowError(\"Handling Delays in host is not supported without persistence.\"));\n        return;\n    }\n\n    assert(_.isPlainObject(wakeupable));\n    assert(_.isString(wakeupable.instanceId));\n    assert(_.isString(wakeupable.workflowName));\n    assert(_.isPlainObject(wakeupable.activeDelay));\n    assert(_.isString(wakeupable.activeDelay.methodName));\n    assert(_.isDate(wakeupable.activeDelay.delayTo));\n    assert(_.isFunction(wakeupable.result.resolve));\n    assert(_.isFunction(wakeupable.result.reject));\n\n    try {\n        //instanceId, workflowName, methodName, args\n        debug(\"Invoking DelayTo instanceId: %s, workflowName:%s, methodName: %s\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName);\n        let result = yield this._invokeMethodOnRunningInstance(wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName, [wakeupable.instanceId, wakeupable.activeDelay.delayTo]);\n        debug(\"DelayTo instanceId: %s, workflowName:%s, methodName: %s invoked.\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName);\n        wakeupable.result.resolve();\n    }\n    catch (e) {\n        if (e instanceof errors.MethodIsNotAccessibleError || e instanceof errors.WorkflowNotFoundError) {\n            debug(\"DelayTo's method is not accessible since it got selected for continuation.\");\n            wakeupable.result.resolve();\n            return;\n        }\n        debug(\"DelayTo instanceId: %s, workflowName:%s, methodName: %s error: %s\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName, e.stack);\n        wakeupable.result.reject(e);\n    }\n});\n\nWorkflowHost.prototype._createWFInstance = function () {\n    let self = this;\n    let insta = new WorkflowInstance(this);\n    insta.on(\n        enums.events.workflowEvent,\n        function (args) {\n            self.onWorkflowEvent(args);\n        });\n    return insta;\n};\n\nWorkflowHost.prototype._deleteWFInstance = function (insta) {\n    insta.removeAllListeners();\n    this._knownRunningInstances.remove(insta.workflowName, insta.id);\n};\n\n/* Shutdown */\n\nWorkflowHost.prototype._verify = function () {\n    if (this._shutdown) {\n        throw new errors.WorkflowError(\"Workflow host has been shut down.\");\n    }\n};\n\nWorkflowHost.prototype.shutdown = function () {\n    if (this._shutdown) {\n        return;\n    }\n    if (this._wakeUp) {\n        this._wakeUp.stop();\n    }\n    this._shutdown = true;\n    this.removeAllListeners();\n};\n\nmodule.exports = WorkflowHost;\n"],"file":"hosting/workflowHost.js","sourceRoot":"/source/"}