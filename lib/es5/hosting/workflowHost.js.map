{"version":3,"names":[],"mappings":"","sources":["hosting/workflowHost.js"],"sourcesContent":["\"use strict\";\r\n\r\nlet WorkflowRegistry = require(\"./workflowRegistry\");\r\nlet _ = require(\"lodash\");\r\nlet Activity = require(\"../activities/activity\");\r\nlet Workflow = require(\"../activities/workflow\");\r\nlet WorkflowPersistence = require(\"./workflowPersistence\");\r\nlet WorkflowInstance = require(\"./workflowInstance\");\r\nlet InstanceIdParser = require(\"./instanceIdParser\");\r\nlet enums = require(\"../common/enums\");\r\nlet Bluebird = require(\"bluebird\");\r\nlet KnownInstaStore = require(\"./knownInstaStore\");\r\nlet specStrings = require(\"../common/specStrings\");\r\nlet errors = require(\"../common/errors\");\r\nlet Serializer = require(\"backpack-node\").system.Serializer;\r\nlet is = require(\"../common/is\");\r\nlet KeepLockAlive = require(\"./keepLockAlive\");\r\nlet asyncHelpers = require(\"../common/asyncHelpers\");\r\nlet async = asyncHelpers.async;\r\nlet WakeUp = require(\"./wakeUp\");\r\nlet assert = require(\"assert\");\r\nlet debug = require(\"debug\")(\"wf4node:WorkflowHost\");\r\nlet EventEmitter = require(\"events\").EventEmitter;\r\nlet util = require(\"util\");\r\n\r\nfunction WorkflowHost(options) {\r\n    EventEmitter.call(this);\r\n\r\n    this._options = _.extend(\r\n        {\r\n            enterLockTimeout: 10000,\r\n            lockRenewalTimeout: 5000,\r\n            alwaysLoadState: false,\r\n            lazyPersistence: true,\r\n            persistence: null,\r\n            serializer: null,\r\n            enablePromotions: false,\r\n            wakeUpOptions: {\r\n                interval: 5000,\r\n                batchSize: 10\r\n            }\r\n        },\r\n        options);\r\n\r\n    this._registry = new WorkflowRegistry(this._options.serializer);\r\n    this._trackers = [];\r\n    this._isInitialized = false;\r\n    this._instanceIdParser = new InstanceIdParser();\r\n    this._persistence = null;\r\n\r\n    if (this._options.persistence !== null) {\r\n        this._persistence = new WorkflowPersistence(this._options.persistence);\r\n    }\r\n    this._knownRunningInstances = new KnownInstaStore();\r\n    this._wakeUp = null;\r\n    this._shutdown = false;\r\n}\r\n\r\nutil.inherits(WorkflowHost, EventEmitter);\r\n\r\nWorkflowHost.events = enums.workflowEvents;\r\n\r\nWorkflowHost.prototype.onWorkflowEvent = function (args) {\r\n    this.emit(WorkflowHost.events.workflowEvent, args);\r\n};\r\n\r\nWorkflowHost.prototype.onWarn = function (error) {\r\n    this.emit(WorkflowHost.events.warn, error);\r\n};\r\n\r\nWorkflowHost.prototype.onStart = function (instance, methodName, args) {\r\n    this.emit(WorkflowHost.events.start, {\r\n        instance: instance,\r\n        methodName: methodName,\r\n        args: args\r\n    });\r\n};\r\n\r\nWorkflowHost.prototype.onInvoke = function (instance, methodName, args, result, idle, error) {\r\n    this.emit(WorkflowHost.events.invoke, {\r\n        instance: instance,\r\n        methodName: methodName,\r\n        args: args,\r\n        idle: idle,\r\n        error: error\r\n    });\r\n};\r\n\r\nWorkflowHost.prototype.onEnd = function (instance, result, cancelled, error) {\r\n    this.emit(WorkflowHost.events.end, {\r\n        instance: instance,\r\n        result: result,\r\n        cancelled: cancelled,\r\n        error: error\r\n    });\r\n};\r\n\r\nObject.defineProperties(\r\n    WorkflowHost.prototype, {\r\n        options: {\r\n            get: function () {\r\n                return this._options;\r\n            }\r\n        },\r\n        isInitialized: {\r\n            get: function () {\r\n                return this._isInitialized;\r\n            }\r\n        },\r\n        instanceIdParser: {\r\n            get: function () {\r\n                return this._instanceIdParser;\r\n            }\r\n        },\r\n        persistence: {\r\n            get: function () {\r\n                return this._persistence;\r\n            }\r\n        },\r\n        _inLockTimeout: {\r\n            get: function () {\r\n                return this.options.lockRenewalTimeout + Math.max(this.options.lockRenewalTimeout * 0.4, 3000);\r\n            }\r\n        }\r\n    });\r\n\r\nWorkflowHost.prototype.registerDeprecatedWorkflow = function (workflow) {\r\n    return this.registerWorkflow(workflow, true);\r\n};\r\n\r\nWorkflowHost.prototype.registerWorkflow = function (workflow, deprecated) {\r\n    this._verify();\r\n    let desc = this._registry.register(workflow, deprecated);\r\n    debug(\"Workflow registered. name: %s, version: %s\", desc.name, desc.version);\r\n    return desc.version;\r\n};\r\n\r\nWorkflowHost.prototype._initialize = function () {\r\n    let self = this;\r\n    if (!this._isInitialized) {\r\n        if (this._options.wakeUpOptions && this._options.wakeUpOptions.interval > 0) {\r\n            this._wakeUp = new WakeUp(this._knownRunningInstances, this._persistence, this._options.wakeUpOptions);\r\n            this._wakeUp.on(\"continue\", function (i) { self._continueWokeUpInstance(i); });\r\n            this._wakeUp.on(\"error\", function (e) { self.onWarn(e); });\r\n            this._wakeUp.start();\r\n        }\r\n\r\n        this._isInitialized = true;\r\n    }\r\n};\r\n\r\nWorkflowHost.prototype.stop = async(function*(workflowName, instanceId) {\r\n    let self = this;\r\n    let remove = function (instanceId) {\r\n        let knownInsta = self._knownRunningInstances.get(workflowName, instanceId);\r\n        if (knownInsta) {\r\n            debug(\"Removing instance: %s\", instanceId);\r\n            self._deleteWFInstance(knownInsta);\r\n            self.onEnd(knownInsta, undefined, true);\r\n        }\r\n    };\r\n\r\n    debug(\"Stopping workflow '%s' with id: '%s'.\", workflowName, instanceId);\r\n\r\n    try {\r\n        if (this._persistence) {\r\n            let lockName = specStrings.hosting.doubleKeys(workflowName, instanceId);\r\n            let lockInfo;\r\n            debug(\"Locking instance: %s\", instanceId);\r\n            lockInfo = yield (this._persistence.enterLock(lockName, this.options.enterLockTimeout, this._inLockTimeout));\r\n            let keepLockAlive = null;\r\n            try {\r\n                debug(\"Locked: %j\", lockInfo);\r\n                keepLockAlive = new KeepLockAlive(this._persistence, lockInfo, this._inLockTimeout, this.options.lockRenewalTimeout);\r\n\r\n                // Do stuff:\r\n                yield this._persistence.removeState(workflowName, instanceId, false, \"STOPPED.\");\r\n                remove(instanceId);\r\n\r\n                debug(\"Removed: %s\", instanceId);\r\n            }\r\n            catch (e) {\r\n                debug(\"Error: %s\", e.stack);\r\n                throw e;\r\n            }\r\n            finally {\r\n                // Unlock:\r\n                debug(\"Unlocking.\");\r\n                if (keepLockAlive) {\r\n                    keepLockAlive.end();\r\n                }\r\n                yield this._persistence.exitLock(lockInfo.id);\r\n            }\r\n        }\r\n        else {\r\n            remove(instanceId);\r\n        }\r\n    }\r\n    catch (e) {\r\n        debug(\"Error: %s\", e.stack);\r\n        throw new errors.WorkflowError(`Cannot stop instance of workflow '${workflowName}' with id: '${instanceId}' because of an internal error:\\n${e.stack}`);\r\n    }\r\n});\r\n\r\nWorkflowHost.prototype.stopDeprecatedVersions = async(function* (workflowName) {\r\n    this._verify();\r\n    debug(\"Stopping outdated versions of workflow '%s'.\", workflowName);\r\n\r\n\r\n\r\n    let count = 0;\r\n    let currentVersion = this._registry.getCurrentVersion(workflowName);\r\n    if (currentVersion) {\r\n        let oldVersionHeaders = yield this._getRunningInstanceHeadersForOtherVersion(workflowName, currentVersion);\r\n        if (oldVersionHeaders.length) {\r\n            debug(\"There is %d old version running. Stopping them.\", oldVersionHeaders.length);\r\n            for (let header of oldVersionHeaders) {\r\n                debug(\"Stopping workflow '%s' of version '%s' with id: '%s'.\", header.workflowName, header.workflowVersion, header.instanceId);\r\n                yield this.stop(workflowName, header.instanceId);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        debug(\"There is no workflow registered by name '%s'.\", workflowName);\r\n    }\r\n    return count;\r\n});\r\n\r\nWorkflowHost.prototype.invokeMethod = async(function* (workflowName, methodName, args) {\r\n    this._verify();\r\n    debug(\"Invoking method: '%s' of workflow: '%s' by arguments '%j'\", workflowName, methodName, args);\r\n\r\n    if (!_(workflowName).isString()) {\r\n        throw new TypeError(\"Argument 'workflowName' is not a string.\");\r\n    }\r\n    workflowName = workflowName.trim();\r\n    if (!_(methodName).isString()) {\r\n        throw new TypeError(\"Argument 'methodName' is not a string.\");\r\n    }\r\n    methodName = methodName.trim();\r\n\r\n    if (!_.isUndefined(args) && !_.isArray(args)) {\r\n        args = [args];\r\n    }\r\n\r\n    let self = this;\r\n\r\n    self._initialize();\r\n\r\n    let instanceId = null;\r\n    let creatable = null;\r\n\r\n    let results = [];\r\n    for (let info of self._registry.methodInfos(workflowName, methodName)) {\r\n        let tryId = self._instanceIdParser.parse(info.instanceIdPath, args);\r\n        if (!_.isUndefined(tryId)) {\r\n            results.push(\r\n                {\r\n                    info: info,\r\n                    id: tryId\r\n                });\r\n        }\r\n    }\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n        debug(\"Possible methods: %j\",\r\n            _(results)\r\n                .map(function (r) {\r\n                    return {\r\n                        workflow: {\r\n                            name: r.info.execContext.rootActivity.name,\r\n                            version: r.info.version\r\n                        },\r\n                        id: r.id\r\n                    };\r\n                })\r\n                .toArray());\r\n    }\r\n\r\n    for (let i = 0; i < results.length; i++) {\r\n        let result = results[i];\r\n        // That finds the latest version:\r\n        if (result.info.canCreateInstance && !result.info.deprecated) {\r\n            creatable = result.info;\r\n        }\r\n        // That finds a running instance with the id:\r\n        if (_.isNull(instanceId) && (yield self._checkIfInstanceRunning(workflowName, result.id))) {\r\n            instanceId = result.id;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (instanceId) {\r\n        debug(\"Found a continuable instance id: %s. Invoking method on that.\", instanceId);\r\n        try {\r\n            let ir = yield (self._invokeMethodOnRunningInstance(instanceId, workflowName, methodName, args));\r\n            debug(\"Invoke completed, result: %j\", ir);\r\n            return ir;\r\n        }\r\n        catch (e) {\r\n            debug(\"Invoke failed: %s\", e.stack);\r\n            throw e;\r\n        }\r\n    }\r\n    else if (creatable) {\r\n        debug(\"Found a creatable workflow (name: '%s', version: '%s'), invoking a create method on that.\", creatable.execContext.rootActivity.name, creatable.version);\r\n        try {\r\n            let cr = yield (self._createInstanceAndInvokeMethod(creatable.execContext, creatable.version, methodName, args));\r\n            debug(\"Create completed, result: %j\", cr);\r\n            return cr;\r\n        }\r\n        catch (e) {\r\n            debug(\"Create failed: %s\", e.stack);\r\n            throw e;\r\n        }\r\n    }\r\n    else {\r\n        debug(\"No continuable workflows have been found.\");\r\n        throw new errors.MethodNotFoundError(\"Cannot create or continue workflow '\" + workflowName + \"' by calling method '\" + methodName + \"'.\");\r\n    }\r\n});\r\n\r\nWorkflowHost.prototype._createInstanceAndInvokeMethod = async(function* (execContext, workflowVersion, methodName, args) {\r\n    let workflowName = execContext.rootActivity.name;\r\n\r\n    let lockInfo = null;\r\n\r\n    if (!this._persistence) {\r\n        let insta = this._createWFInstance();\r\n        let result = yield (insta.create(execContext, workflowVersion, methodName, args, lockInfo));\r\n        this._knownRunningInstances.add(workflowName, insta);\r\n        this.onStart(insta, methodName, args);\r\n        return result;\r\n    }\r\n    else {\r\n        lockInfo = {\r\n            id: null,\r\n            name: null,\r\n            heldTo: null\r\n        };\r\n        // When lock will held, then we should keep it alive:\r\n        let keepLockAlive = new KeepLockAlive(this._persistence, lockInfo, this._inLockTimeout, this.options.lockRenewalTimeout);\r\n        try {\r\n            let insta = this._createWFInstance();\r\n            let result = yield (insta.create(execContext, workflowVersion, methodName, args, lockInfo));\r\n\r\n            if (insta.execState === enums.activityStates.idle) {\r\n                this._knownRunningInstances.add(workflowName, insta);\r\n\r\n                // Persist and unlock:\r\n                let err = null;\r\n                try {\r\n                    yield this._persistence.persistState(insta);\r\n                    this.onStart(insta, methodName, args);\r\n                }\r\n                catch (e) {\r\n                    debug(\"Cannot persist instance of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\r\n                    this._knownRunningInstances.remove(workflowName, insta.id);\r\n                    err = e;\r\n                }\r\n                try {\r\n                    yield this._persistence.exitLock(lockInfo.id);\r\n                }\r\n                catch (e) {\r\n                    debug(\"Cannot exit lock of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\r\n                    this.onWarn(e);\r\n                }\r\n                if (err) {\r\n                    throw err;\r\n                }\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }\r\n        finally {\r\n            keepLockAlive.end();\r\n        }\r\n    }\r\n});\r\n\r\nWorkflowHost.prototype._throwIfRecoverable = function (error, workflowName, methodName) {\r\n    if (error instanceof errors.MethodIsNotAccessibleError) {\r\n        debug(\"Method '%s' of workflow '%s' is not accessible at the current state, bacause it might be stepped on another instance to another state tha is exists at current in this host. Client should retry.\", methodName, workflowName);\r\n        throw error;\r\n    }\r\n};\r\n\r\nWorkflowHost.prototype._invokeMethodOnRunningInstance = async(function* (instanceId, workflowName, methodName, args) {\r\n    let self = this;\r\n\r\n    if (!self._persistence) {\r\n        let insta = yield (self._verifyAndRestoreInstanceState(instanceId, workflowName, methodName, args));\r\n        try {\r\n            let result = yield (insta.callMethod(methodName, args));\r\n            if (insta.execState === enums.activityStates.idle) {\r\n                this.onInvoke(insta, methodName, args, result, true, null);\r\n                return result;\r\n            }\r\n            else if (insta.execState === enums.activityStates.complete) {\r\n                self._deleteWFInstance(insta);\r\n                this.onInvoke(insta, methodName, args, result, false, null);\r\n                this.onEnd(insta, result, false, null);\r\n                return result;\r\n            }\r\n            else {\r\n                throw new errors.WorkflowError(\"Instance '\" + insta.id + \"' is in an invalid state '\" + insta.execState + \"' after invocation of the method '\" + methodName + \"'.\");\r\n            }\r\n        }\r\n        catch (e) {\r\n            this._throwIfRecoverable(e, workflowName, methodName);\r\n            self._deleteWFInstance(insta);\r\n            this.onInvoke(insta, methodName, args, undefined, false, e);\r\n            this.onEnd(insta, undefined, false, e);\r\n            throw e;\r\n        }\r\n    }\r\n    else {\r\n        // Lock it:\r\n        let lockName = specStrings.hosting.doubleKeys(workflowName, instanceId);\r\n        let lockInfo;\r\n        let keepLockAlive = null;\r\n        try {\r\n            debug(\"Locking instance.\");\r\n            lockInfo = yield (self._persistence.enterLock(lockName, self.options.enterLockTimeout, self._inLockTimeout));\r\n            debug(\"Locked: %j\", lockInfo);\r\n\r\n            // When lock will held, then we should keep it alive:\r\n            keepLockAlive = new KeepLockAlive(self._persistence, lockInfo, self._inLockTimeout, self.options.lockRenewalTimeout);\r\n\r\n            // LOCKED\r\n            let insta = yield (self._verifyAndRestoreInstanceState(instanceId, workflowName, methodName, args));\r\n            let endWithError = async(function*(e) {\r\n                self._deleteWFInstance(insta);\r\n                try {\r\n                    yield (self._persistence.removeState(workflowName, insta.id, false, e));\r\n                }\r\n                catch (removeE) {\r\n                    debug(\"Cannot remove state of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + removeE.stack);\r\n                    self.onWarn(removeE);\r\n                }\r\n                self.onInvoke(insta, methodName, args, undefined, false, e);\r\n                self.onEnd(insta, undefined, false, e);\r\n            });\r\n            try {\r\n                let persistAndUnlock = function () {\r\n                    return self._persistence.persistState(insta)\r\n                        .finally(function () {\r\n                            debug(\"Unlocking: %j\", lockInfo);\r\n                            return self._persistence.exitLock(lockInfo.id)\r\n                                .then(function () {\r\n                                    debug(\"Unlocked.\");\r\n                                },\r\n                                function (e) {\r\n                                    debug(\"Cannot exit lock for workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\r\n                                    self.onWarn(e);\r\n                                })\r\n                                .finally(function () {\r\n                                    keepLockAlive.end();\r\n                                });\r\n                        });\r\n                };\r\n                let result = yield (insta.callMethod(methodName, args));\r\n                if (insta.execState === enums.activityStates.idle) {\r\n                    // Persist and unlock:\r\n                    if (self.options.lazyPersistence) {\r\n                        setImmediate(function () {\r\n                            persistAndUnlock()\r\n                                .then(function () {\r\n                                    self.onInvoke(insta, methodName, args, result, true, null);\r\n                                },\r\n                                function(e) {\r\n                                    endWithError(e);\r\n                                });\r\n                        });\r\n                    }\r\n                    else {\r\n                        yield persistAndUnlock();\r\n                        this.onInvoke(insta, methodName, args, result, true, null);\r\n                    }\r\n\r\n                    return result;\r\n                }\r\n                else if (insta.execState === enums.activityStates.complete) {\r\n                    self._deleteWFInstance(insta);\r\n                    this.onInvoke(insta, methodName, args, result, false, null);\r\n                    this.onEnd(insta, result, false, null);\r\n                    try {\r\n                        try {\r\n                            yield self._persistence.removeState(workflowName, insta.id, true);\r\n                        }\r\n                        catch (e) {\r\n                            debug(\"Cannot remove state of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\r\n                            this.onWarn(e);\r\n                        }\r\n\r\n                        try {\r\n                            yield self._persistence.exitLock(lockInfo.id);\r\n                        }\r\n                        catch (e) {\r\n                            debug(\"Cannot exit lock of workflow name: '\" + workflowName + \"' instance id '\" + insta.id + \"':\\n\" + e.stack);\r\n                            this.onWarn(e);\r\n                        }\r\n                    }\r\n                    finally {\r\n                        keepLockAlive.end();\r\n                    }\r\n                    return result;\r\n                }\r\n                else {\r\n                    throw new errors.WorkflowError(\"Instance '\" + insta.id + \"' is in an invalid state '\" + insta.execState + \"' after invocation of the method '\" + methodName + \"'.\");\r\n                }\r\n            }\r\n            catch (e) {\r\n                this._throwIfRecoverable(e, workflowName, methodName);\r\n                yield endWithError(e);\r\n                throw e;\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (keepLockAlive) {\r\n                keepLockAlive.end();\r\n            }\r\n            if (lockInfo) {\r\n                try {\r\n                    yield self._persistence.exitLock(lockInfo.id);\r\n                }\r\n                catch (exitE) {\r\n                    debug(\"Cannot exit lock '\" + lockInfo.id + \"':\\n\" + exitE.stack);\r\n                    this.onWarn(exitE);\r\n                }\r\n            }\r\n            if (e instanceof errors.TimeoutError) {\r\n                let msg = \"Cannot call method of workflow '\" + workflowName + \"', because '\" + methodName + \"' is locked.\";\r\n                debug(msg);\r\n                throw new errors.MethodIsNotAccessibleError(msg);\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n});\r\n\r\nWorkflowHost.prototype._enterLockForCreatedInstance = async(function* (insta, lockInfo) {\r\n    let li = yield (this._persistence.enterLock(specStrings.hosting.doubleKeys(insta.workflowName, insta.id), this.options.enterLockTimeout, this._getInLockTimeout()));\r\n    if (yield (this._persistence.isRunning(insta.workflowName, insta.id))) {\r\n        throw new errors.WorkflowError(\"Cannot create instance of workflow '\" + insta.workflowName + \"' by id '\" + insta.id + \"' because it's already exists.\");\r\n    }\r\n    lockInfo.id = li.id;\r\n    lockInfo.name = li.name;\r\n    lockInfo.heldTo = li.heldTo;\r\n});\r\n\r\nWorkflowHost.prototype._getInLockTimeout = function () {\r\n    return this.options.lockRenewalTimeout + Math.max(this.options.lockRenewalTimeout * 0.4, 3000);\r\n};\r\n\r\nWorkflowHost.prototype._verifyAndRestoreInstanceState = async(function* (instanceId, workflowName, methodName, args) {\r\n    let self = this;\r\n    let insta = null;\r\n    if (self._persistence) {\r\n        let header = yield (self._persistence.getRunningInstanceIdHeader(workflowName, instanceId));\r\n        if (header) {\r\n            insta = yield (self._restoreInstanceState(instanceId, workflowName, header.workflowVersion, header.updatedOn));\r\n        }\r\n    }\r\n    else {\r\n        insta = self._knownRunningInstances.get(workflowName, instanceId);\r\n    }\r\n    if (!insta) {\r\n        throw new errors.WorkflowNotFoundError(`Worflow (name: '${workflowName}', id: '${instanceId}') has been deleted since the lock has been taken.`);\r\n    }\r\n\r\n    return insta;\r\n});\r\n\r\nWorkflowHost.prototype._restoreInstanceState = async(function* (instanceId, workflowName, workflowVersion, actualTimestamp) {\r\n    let self = this;\r\n\r\n    if (!self._persistence) {\r\n        throw new Error(\"Cannot restore instance from persistence, because host has no persistence registered.\");\r\n    }\r\n\r\n    let insta = self._knownRunningInstances.get(workflowName, instanceId);\r\n    if (_.isUndefined(insta)) {\r\n        let wfDesc = self._registry.getDesc(workflowName, workflowVersion);\r\n        insta = self._createWFInstance();\r\n        insta.setWorkflow(wfDesc.execContext, workflowVersion, instanceId);\r\n    }\r\n\r\n    if (insta.updatedOn === null || insta.updatedOn.getTime() !== actualTimestamp.getTime() || self.options.alwaysLoadState) {\r\n        let state = yield (self._persistence.loadState(workflowName, instanceId));\r\n        insta.restoreState(state);\r\n        return insta;\r\n    }\r\n    else {\r\n        return insta;\r\n    }\r\n});\r\n\r\nWorkflowHost.prototype._checkIfInstanceRunning = async(function* (workflowName, instanceId) {\r\n    if (this._persistence) {\r\n        return (yield this._persistence.isRunning(workflowName, instanceId));\r\n    }\r\n    return this._knownRunningInstances.exists(workflowName, instanceId);\r\n});\r\n\r\nWorkflowHost.prototype._getRunningInstanceHeadersForOtherVersion = async(function* (workflowName, version) {\r\n    if (this._persistence) {\r\n        return (yield this._persistence.getRunningInstanceHeadersForOtherVersion(workflowName, version));\r\n    }\r\n    return this._knownRunningInstances.getRunningInstanceHeadersForOtherVersion(workflowName, version);\r\n});\r\n\r\nWorkflowHost.prototype.addTracker = function (tracker) {\r\n    this._verify();\r\n\r\n    if (!_.isObject(tracker)) {\r\n        throw new TypeError(\"Argument is not an object.\");\r\n    }\r\n    this._trackers.push(tracker);\r\n    this._knownRunningInstances.addTracker(tracker);\r\n};\r\n\r\n/* Wake Up*/\r\n\r\nWorkflowHost.prototype._continueWokeUpInstance = async(function*(wakeupable) {\r\n    if (this._shutdown) {\r\n        wakeupable.result.resolve();\r\n        return;\r\n    }\r\n    if (!this._persistence) {\r\n        wakeupable.result.reject(new errors.WorkflowError(\"Handling Delays in host is not supported without persistence.\"));\r\n        return;\r\n    }\r\n\r\n    assert(_.isPlainObject(wakeupable));\r\n    assert(_.isString(wakeupable.instanceId));\r\n    assert(_.isString(wakeupable.workflowName));\r\n    assert(_.isPlainObject(wakeupable.activeDelay));\r\n    assert(_.isString(wakeupable.activeDelay.methodName));\r\n    assert(_.isDate(wakeupable.activeDelay.delayTo));\r\n    assert(_.isFunction(wakeupable.result.resolve));\r\n    assert(_.isFunction(wakeupable.result.reject));\r\n\r\n    try {\r\n        //instanceId, workflowName, methodName, args\r\n        debug(\"Invoking DelayTo instanceId: %s, workflowName:%s, methodName: %s\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName);\r\n        let result = yield this._invokeMethodOnRunningInstance(wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName, [wakeupable.instanceId, wakeupable.activeDelay.delayTo]);\r\n        debug(\"DelayTo instanceId: %s, workflowName:%s, methodName: %s invoked.\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName);\r\n        wakeupable.result.resolve();\r\n    }\r\n    catch (e) {\r\n        if (e instanceof errors.MethodIsNotAccessibleError || e instanceof errors.WorkflowNotFoundError) {\r\n            debug(\"DelayTo's method is not accessible since it got selected for continuation.\");\r\n            wakeupable.result.resolve();\r\n            return;\r\n        }\r\n        debug(\"DelayTo instanceId: %s, workflowName:%s, methodName: %s error: %s\", wakeupable.instanceId, wakeupable.workflowName, wakeupable.activeDelay.methodName, e.stack);\r\n        wakeupable.result.reject(e);\r\n    }\r\n});\r\n\r\nWorkflowHost.prototype._createWFInstance = function () {\r\n    let self = this;\r\n    let insta = new WorkflowInstance(this);\r\n    insta.on(\r\n        enums.events.workflowEvent,\r\n        function (args) {\r\n            self.onWorkflowEvent(args);\r\n        });\r\n    return insta;\r\n};\r\n\r\nWorkflowHost.prototype._deleteWFInstance = function (insta) {\r\n    insta.removeAllListeners();\r\n    this._knownRunningInstances.remove(insta.workflowName, insta.id);\r\n};\r\n\r\n/* Shutdown */\r\n\r\nWorkflowHost.prototype._verify = function () {\r\n    if (this._shutdown) {\r\n        throw new errors.WorkflowError(\"Workflow host has been shut down.\");\r\n    }\r\n};\r\n\r\nWorkflowHost.prototype.shutdown = function () {\r\n    if (this._shutdown) {\r\n        return;\r\n    }\r\n    if (this._wakeUp) {\r\n        this._wakeUp.stop();\r\n    }\r\n    this._shutdown = true;\r\n    this.removeAllListeners();\r\n};\r\n\r\nmodule.exports = WorkflowHost;\r\n"],"file":"hosting/workflowHost.js","sourceRoot":"/source/"}