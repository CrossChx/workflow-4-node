{"version":3,"names":[],"mappings":"","sources":["hosting/workflowInstance.js"],"sourcesContent":["\"use strict\";\n\nlet Workflow = require(\"../activities/workflow\");\nlet ActivityExecutionEngine = require(\"../activities/activityExecutionEngine\");\nlet BeginMethod = require(\"../activities/beginMethod\");\nlet EndMethod = require(\"../activities/endMethod\");\nlet errors = require(\"../common/errors\");\nlet enums = require(\"../common/enums\");\nlet specStrings = require(\"../common/specStrings\");\nlet _ = require(\"lodash\");\nlet constants = require(\"../common/constants\");\nlet Bluebird = require(\"bluebird\");\nlet is = require(\"../common/is\");\nlet asyncHelpers = require(\"../common/asyncHelpers\");\nlet async = asyncHelpers.async;\nlet EventEmitter = require('events').EventEmitter;\nlet util = require(\"util\");\nlet debug = require(\"debug\")(\"wf4node:WorkflowInstance\");\n\nfunction WorkflowInstance(host) {\n    EventEmitter.call(this);\n\n    this._host = host;\n    this.id = null;\n    this._engine = null;\n    this._createdOn = null;\n    this._beginMethodWithCreateInstCallback = null;\n    this._endMethodCallback = null;\n    this._idleInstanceIdPathCallback = null;\n    this._activeDelays = [];\n    this._workflowVersion = null;\n}\n\nutil.inherits(WorkflowInstance, EventEmitter);\n\nObject.defineProperties(\n    WorkflowInstance.prototype, {\n        execState: {\n            get: function () {\n                return this._engine ? this._engine.execState : null;\n            }\n        },\n        workflowName: {\n            get: function () {\n                return this._engine ? this._engine.rootActivity.name.trim() : null;\n            }\n        },\n        workflowVersion: {\n            get: function () {\n                return this._workflowVersion;\n            }\n        },\n        createdOn: {\n            get: function () {\n                return this._createdOn;\n            }\n        },\n        updatedOn: {\n            get: function () {\n                return this._engine ? this._engine.updatedOn : null;\n            }\n        },\n        activeDelays: {\n            get: function () {\n                return this._activeDelays;\n            }\n        },\n        persistence: {\n            get: function() {\n                return this._host._persistence;\n            }\n        }\n    });\n\nWorkflowInstance.prototype.create = async(function* (workflow, workflowVersion, methodName, args, lockInfo) {\n    let self = this;\n\n    self.setWorkflow(workflow, workflowVersion);\n    self._resetCallbacksAndState();\n\n    let createMethodReached = false;\n    let instanceIdPath = null;\n    self._beginMethodWithCreateInstCallback = function (mn, ip) {\n        if (mn === methodName) {\n            createMethodReached = true;\n            instanceIdPath = ip;\n        }\n    };\n\n    self._createdOn = new Date();\n\n    try {\n        if (self._engine.isIdle(yield self._engine.invoke())) {\n            if (createMethodReached) {\n                self._resetCallbacksAndState();\n\n                if (instanceIdPath) {\n                    if (_.isUndefined(self.id = self._host._instanceIdParser.parse(instanceIdPath, args))) {\n                        throw new errors.WorkflowError(\"Cannot parse BeginMethod's instanceIdPath '\" + instanceIdPath + \"' on arguments of method '\" + methodName + \"'.\");\n                    }\n                    yield (self._enterLockForCreatedInstance(lockInfo));\n                }\n\n                let createEndMethodReached = false;\n                let result;\n                let endInstanceIdPath = null;\n                self._endMethodCallback =\n                    function (mn, ip, r) {\n                        if (mn === methodName) {\n                            createEndMethodReached = true;\n                            endInstanceIdPath = ip;\n                            result = r;\n                        }\n                    };\n\n                let idleMethods = [];\n                self._idleInstanceIdPathCallback =\n                    function (mn, ip) {\n                        idleMethods.push(\n                            {\n                                methodName: mn,\n                                instanceIdPath: ip\n                            });\n                    };\n\n                yield (self._engine.resumeBookmark(specStrings.hosting.createBeginMethodBMName(methodName), enums.activityStates.complete, args));\n\n                if (createEndMethodReached) {\n                    if (_.isUndefined(self.id)) {\n                        if (endInstanceIdPath) {\n                            if (_.isUndefined(self.id = self._host._instanceIdParser.parse(endInstanceIdPath, result))) {\n                                throw new errors.WorkflowError(\"Cannot parse EndMethods's instanceIdPath '\" + instanceIdPath + \"' on arguments of method '\" + methodName + \"'.\");\n                            }\n                            yield self._enterLockForCreatedInstance(lockInfo);\n                        }\n                        else {\n                            throw new errors.WorkflowError(\"BeginMethod or EndMethod of method '\" + methodName + \"' doesn't specify an instanceIdPath property value.\");\n                        }\n                    }\n                }\n                else {\n                    throw new errors.WorkflowError(\"Workflow has been completed or gone to idle without reaching an EndMethod activity of method '\" + methodName + \"'.\");\n                }\n\n                if (self.execState === enums.activityStates.idle) {\n                    if (idleMethods.length === 0) {\n                        throw new errors.WorkflowError(\"Workflow has gone to idle, but there is no active BeginMethod activities to wait for.\");\n                    }\n                }\n                else {\n                    if (idleMethods.length !== 0) {\n                        throw new errors.WorkflowError(\"Workflow has completed, but there is active BeginMethod activities to wait for.\");\n                    }\n                }\n\n                return result;\n            }\n            else {\n                throw new errors.WorkflowError(\"Workflow has gone to idle without reaching an instance creator BeginMethod activity of method '\" + methodName + \"'.\");\n            }\n        }\n        else {\n            throw new errors.WorkflowError(\"Workflow has been completed without reaching an instance creator BeginMethod activity.\");\n        }\n    }\n    catch (e) {\n        debug(\"Create error: %s\", e.stack);\n        if (e instanceof errors.TimeoutError) {\n            throw new errors.MethodIsNotAccessibleError(\"Cannot create instanceof workflow '\" + self.workflowName + \"', because '\" + methodName + \"' is locked.\");\n        }\n        if (e instanceof errors.BookmarkNotFoundError) {\n            throw new errors.MethodIsNotAccessibleError(\"Cannot create instanceof workflow '\" + self.workflowName + \"', because bookmark of '\" + methodName + \"' doesn't exist.\");\n        }\n        throw e;\n    }\n    finally {\n        self._resetCallbacks();\n    }\n});\n\nWorkflowInstance.prototype._enterLockForCreatedInstance = async(\n    function* (lockInfo) {\n        if (lockInfo) {\n            yield this._host._enterLockForCreatedInstance(this, lockInfo);\n        }\n    });\n\nWorkflowInstance.prototype.setWorkflow = function (workflow, workflowVersion, instanceId) {\n    let self = this;\n    if (!(workflow instanceof Workflow)) {\n        throw new TypeError(\"Workflow argument expected.\");\n    }\n    if (!(_.isString(workflowVersion)) || !workflowVersion) {\n        throw new TypeError(\"Workflow version expected.\");\n    }\n    this._workflowVersion = workflowVersion;\n    this._engine = new ActivityExecutionEngine(workflow, this);\n    this._engine.on(\n        enums.events.workflowEvent,\n        function (args) {\n            let arr = _.toArray(args);\n            arr.splice(0, 0, self.instanceId);\n            self.emit(enums.events.workflowEvent, args);\n        });\n    this._addMyTrackers();\n    if (!_.isUndefined(instanceId)) {\n        this.id = instanceId;\n    }\n    this._copyParsFromHost();\n};\n\nWorkflowInstance.prototype.callMethod = async(function* (methodName, args) {\n    let self = this;\n\n    self._resetCallbacksAndState();\n\n    let endMethodReached = false;\n    let result = null;\n    self._endMethodCallback =\n        function (mn, ip, r) {\n            if (mn === methodName) {\n                endMethodReached = true;\n                result = r;\n            }\n        };\n\n    let idleMethods = [];\n    self._idleInstanceIdPathCallback =\n        function (mn, ip) {\n            idleMethods.push(\n                {\n                    methodName: mn,\n                    instanceIdPath: ip\n                });\n        };\n\n    try {\n        yield self._engine.resumeBookmark(specStrings.hosting.createBeginMethodBMName(methodName), enums.activityStates.complete, args);\n\n        if (!endMethodReached) {\n            throw new errors.WorkflowError(\"Workflow has been completed or gone to idle without reaching an EndMethod activity of method name '\" + methodName + \"'.\");\n        }\n\n        if (self.execState === enums.activityStates.idle) {\n            if (idleMethods.length === 0) {\n                throw new errors.WorkflowError(\"Workflow has gone to idle, but there is no active BeginMethod activities to wait for.\");\n            }\n        }\n        else {\n            if (idleMethods.length !== 0) {\n                throw new errors.WorkflowError(\"Workflow has completed, but there is active BeginMethod activities to wait for.\");\n            }\n        }\n\n        return result;\n    }\n    catch (e) {\n        debug(\"Call method error: %s\", e.stack);\n        if (e instanceof errors.BookmarkNotFoundError) {\n            throw new errors.MethodIsNotAccessibleError(\"Cannot call method '\" + methodName + \"' of workflow '\" + self.workflowName + \"', because its bookmark doesn't exist.\");\n        }\n        throw e;\n    }\n    finally {\n        self._resetCallbacks();\n    }\n});\n\nWorkflowInstance.prototype._copyParsFromHost = function () {\n    for (let t of this._host._trackers) {\n        this._engine.addTracker(t);\n    }\n};\n\nWorkflowInstance.prototype._addMyTrackers = function () {\n    this._addBeginMethodWithCreateInstHelperTracker();\n    this._addEndMethodHelperTracker();\n    this._addIdleInstanceIdPathTracker();\n};\n\nWorkflowInstance.prototype._resetCallbacks = function () {\n    this._beginMethodWithCreateInstCallback = null;\n    this._endMethodCallback = null;\n    this._idleInstanceIdPathCallback = null;\n};\n\nWorkflowInstance.prototype._resetCallbacksAndState = function () {\n    this._resetCallbacks();\n    this._activeDelays = [];\n};\n\nWorkflowInstance.prototype._addBeginMethodWithCreateInstHelperTracker = function () {\n    let self = this;\n    let tracker = {\n        activityStateFilter: function (args) {\n            return self._beginMethodWithCreateInstCallback &&\n                args.scope.$activity instanceof BeginMethod &&\n                args.scope.canCreateInstance &&\n                _.isString(args.scope.methodName) &&\n                (!args.scope.instanceIdPath || _.isString(args.scope.instanceIdPath)) &&\n                args.reason === enums.activityStates.idle;\n        },\n        activityStateChanged: function (args) {\n            let methodName = args.scope.methodName.trim();\n            let instanceIdPath = args.scope.instanceIdPath ? args.scope.instanceIdPath.trim() : null;\n            self._beginMethodWithCreateInstCallback(methodName, instanceIdPath);\n        }\n    };\n    self._engine.addTracker(tracker);\n};\n\nWorkflowInstance.prototype._addEndMethodHelperTracker = function () {\n    let self = this;\n    let tracker = {\n        activityStateFilter: function (args) {\n            return self._endMethodCallback &&\n                args.scope.$activity instanceof EndMethod &&\n                _.isString(args.scope.methodName) &&\n                (!args.scope.instanceIdPath || _.isString(args.scope.instanceIdPath)) &&\n                args.reason === enums.activityStates.complete;\n        },\n        activityStateChanged: function (args) {\n            let methodName = args.scope.methodName.trim();\n            let instanceIdPath = args.scope.instanceIdPath ? args.scope.instanceIdPath.trim() : null;\n            self._endMethodCallback(methodName, instanceIdPath, args.result);\n        }\n    };\n    self._engine.addTracker(tracker);\n};\n\nWorkflowInstance.prototype._addIdleInstanceIdPathTracker = function () {\n    let self = this;\n    let tracker = {\n        activityStateFilter: function (args) {\n            return self._idleInstanceIdPathCallback &&\n                args.scope.$activity instanceof BeginMethod &&\n                _.isString(args.scope.methodName) &&\n                _.isString(args.scope.instanceIdPath) &&\n                args.reason === enums.activityStates.idle;\n        },\n        activityStateChanged: function (args) {\n            let methodName = args.scope.methodName.trim();\n            let instanceIdPath = args.scope.instanceIdPath.trim();\n            self._idleInstanceIdPathCallback(methodName, instanceIdPath);\n\n            // This is where a method goes idle.\n            // So if it a DelayTo method, we should remember that.\n            if (specStrings.hosting.isDelayToMethodName(methodName)) {\n                self._activeDelays.push({\n                    methodName: methodName,\n                    delayTo: args.scope.delayTo\n                });\n            }\n        }\n    };\n    self._engine.addTracker(tracker);\n};\n\nWorkflowInstance.prototype.getStateToPersist = function () {\n    let sp = this._engine.getStateAndPromotions(this._host.options.serializer, this._host.options.enablePromotions);\n    return {\n        instanceId: this.id,\n        createdOn: this.createdOn,\n        workflowName: this.workflowName,\n        workflowVersion: this.workflowVersion,\n        updatedOn: this._engine.updatedOn,\n        state: sp.state,\n        promotedProperties: sp.promotedProperties,\n        activeDelays: this._activeDelays\n    };\n};\n\nWorkflowInstance.prototype.restoreState = function (json) {\n    if (!_.isObject(json)) {\n        throw new TypeError(\"Argument 'json' is not an object.\");\n    }\n    if (json.instanceId !== this.id) {\n        throw new Error(\"State instanceId property value of '\" + json.instanceId + \"' is different than the current instance id '\" + this.id + \"'.\");\n    }\n    if (json.workflowName !== this.workflowName) {\n        throw new Error(\"State workflowName property value of '\" + json.workflowName + \"' is different than the current Workflow name '\" + this.workflowName + \"'.\");\n    }\n    if (json.workflowVersion !== this.workflowVersion) {\n        throw new Error(\"State workflowVersion property value of '\" + json.workflowVersion + \"' is different than the current Workflow version '\" + this.workflowVersion + \"'.\");\n    }\n    if (!_.isDate(json.createdOn)) {\n        throw new Error(\"State createdOn property value of '\" + json.createdOn + \"' is not a Date.\");\n    }\n\n    this._createdOn = json.createdOn;\n    this._engine.setState(this._host.options.serializer, json.state);\n};\n\nWorkflowInstance.prototype.addTracker = function(tracker) {\n    this._engine.addTracker(tracker);\n};\n\nmodule.exports = WorkflowInstance;\n"],"file":"hosting/workflowInstance.js","sourceRoot":"/source/"}