{"version":3,"names":[],"mappings":"","sources":["hosting/workflowInstance.js"],"sourcesContent":["\"use strict\";\r\n\r\nlet Workflow = require(\"../activities/workflow\");\r\nlet ActivityExecutionContext = require(\"../activities/activityExecutionContext\");\r\nlet ActivityExecutionEngine = require(\"../activities/activityExecutionEngine\");\r\nlet BeginMethod = require(\"../activities/beginMethod\");\r\nlet EndMethod = require(\"../activities/endMethod\");\r\nlet errors = require(\"../common/errors\");\r\nlet enums = require(\"../common/enums\");\r\nlet specStrings = require(\"../common/specStrings\");\r\nlet _ = require(\"lodash\");\r\nlet constants = require(\"../common/constants\");\r\nlet Bluebird = require(\"bluebird\");\r\nlet is = require(\"../common/is\");\r\nlet asyncHelpers = require(\"../common/asyncHelpers\");\r\nlet async = asyncHelpers.async;\r\nlet EventEmitter = require('events').EventEmitter;\r\nlet util = require(\"util\");\r\nlet debug = require(\"debug\")(\"wf4node:WorkflowInstance\");\r\n\r\nfunction WorkflowInstance(host) {\r\n    EventEmitter.call(this);\r\n\r\n    this._host = host;\r\n    this.id = null;\r\n    this._engine = null;\r\n    this.createdOn = null;\r\n    this._beginMethodWithCreateInstCallback = null;\r\n    this._endMethodCallback = null;\r\n    this._idleInstanceIdPathCallback = null;\r\n    this.activeDelays = [];\r\n    this.workflowVersion = null;\r\n}\r\n\r\nutil.inherits(WorkflowInstance, EventEmitter);\r\n\r\nObject.defineProperties(\r\n    WorkflowInstance.prototype, {\r\n        execState: {\r\n            get: function () {\r\n                return this._engine ? this._engine.execState : null;\r\n            }\r\n        },\r\n        workflowName: {\r\n            get: function () {\r\n                return this._engine ? this._engine.rootActivity.name.trim() : null;\r\n            }\r\n        },\r\n        updatedOn: {\r\n            get: function () {\r\n                return this._engine ? this._engine.updatedOn : null;\r\n            }\r\n        },\r\n        persistence: {\r\n            get: function() {\r\n                return this._host._persistence;\r\n            }\r\n        }\r\n    });\r\n\r\nWorkflowInstance.prototype.create = async(function* (execContext, workflowVersion, methodName, args, lockInfo) {\r\n    let self = this;\r\n\r\n    self.setWorkflow(execContext, workflowVersion);\r\n    self._resetCallbacksAndState();\r\n\r\n    let createMethodReached = false;\r\n    let instanceIdPath = null;\r\n    self._beginMethodWithCreateInstCallback = function (mn, ip) {\r\n        if (mn === methodName) {\r\n            createMethodReached = true;\r\n            instanceIdPath = ip;\r\n        }\r\n    };\r\n\r\n    self.createdOn = new Date();\r\n\r\n    try {\r\n        if (self._engine.isIdle(yield self._engine.invoke())) {\r\n            if (createMethodReached) {\r\n                self._resetCallbacksAndState();\r\n\r\n                if (instanceIdPath) {\r\n                    if (_.isUndefined(self.id = self._host._instanceIdParser.parse(instanceIdPath, args))) {\r\n                        throw new errors.WorkflowError(\"Cannot parse BeginMethod's instanceIdPath '\" + instanceIdPath + \"' on arguments of method '\" + methodName + \"'.\");\r\n                    }\r\n                    yield (self._enterLockForCreatedInstance(lockInfo));\r\n                }\r\n\r\n                let createEndMethodReached = false;\r\n                let result;\r\n                let endInstanceIdPath = null;\r\n                self._endMethodCallback =\r\n                    function (mn, ip, r) {\r\n                        if (mn === methodName) {\r\n                            createEndMethodReached = true;\r\n                            endInstanceIdPath = ip;\r\n                            result = r;\r\n                        }\r\n                    };\r\n\r\n                let idleMethods = [];\r\n                self._idleInstanceIdPathCallback =\r\n                    function (mn, ip) {\r\n                        idleMethods.push(\r\n                            {\r\n                                methodName: mn,\r\n                                instanceIdPath: ip\r\n                            });\r\n                    };\r\n\r\n                yield (self._engine.resumeBookmark(specStrings.hosting.createBeginMethodBMName(methodName), enums.activityStates.complete, args));\r\n\r\n                if (createEndMethodReached) {\r\n                    if (_.isUndefined(self.id)) {\r\n                        if (endInstanceIdPath) {\r\n                            if (_.isUndefined(self.id = self._host._instanceIdParser.parse(endInstanceIdPath, result))) {\r\n                                throw new errors.WorkflowError(\"Cannot parse EndMethods's instanceIdPath '\" + instanceIdPath + \"' on arguments of method '\" + methodName + \"'.\");\r\n                            }\r\n                            yield self._enterLockForCreatedInstance(lockInfo);\r\n                        }\r\n                        else {\r\n                            throw new errors.WorkflowError(\"BeginMethod or EndMethod of method '\" + methodName + \"' doesn't specify an instanceIdPath property value.\");\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    throw new errors.WorkflowError(\"Workflow has been completed or gone to idle without reaching an EndMethod activity of method '\" + methodName + \"'.\");\r\n                }\r\n\r\n                if (self.execState === enums.activityStates.idle) {\r\n                    if (idleMethods.length === 0) {\r\n                        throw new errors.WorkflowError(\"Workflow has gone to idle, but there is no active BeginMethod activities to wait for.\");\r\n                    }\r\n                }\r\n                else {\r\n                    if (idleMethods.length !== 0) {\r\n                        throw new errors.WorkflowError(\"Workflow has completed, but there is active BeginMethod activities to wait for.\");\r\n                    }\r\n                }\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                throw new errors.WorkflowError(\"Workflow has gone to idle without reaching an instance creator BeginMethod activity of method '\" + methodName + \"'.\");\r\n            }\r\n        }\r\n        else {\r\n            throw new errors.WorkflowError(\"Workflow has been completed without reaching an instance creator BeginMethod activity.\");\r\n        }\r\n    }\r\n    catch (e) {\r\n        debug(\"Create error: %s\", e.stack);\r\n        if (e instanceof errors.TimeoutError) {\r\n            throw new errors.MethodIsNotAccessibleError(\"Cannot create instanceof workflow '\" + self.workflowName + \"', because '\" + methodName + \"' is locked.\");\r\n        }\r\n        if (e instanceof errors.BookmarkNotFoundError) {\r\n            throw new errors.MethodIsNotAccessibleError(\"Cannot create instanceof workflow '\" + self.workflowName + \"', because bookmark of '\" + methodName + \"' doesn't exist.\");\r\n        }\r\n        throw e;\r\n    }\r\n    finally {\r\n        self._resetCallbacks();\r\n    }\r\n});\r\n\r\nWorkflowInstance.prototype._enterLockForCreatedInstance = async(\r\n    function* (lockInfo) {\r\n        if (lockInfo) {\r\n            yield this._host._enterLockForCreatedInstance(this, lockInfo);\r\n        }\r\n    });\r\n\r\nWorkflowInstance.prototype.setWorkflow = function (execContext, workflowVersion, instanceId) {\r\n    let self = this;\r\n    if (!(execContext instanceof ActivityExecutionContext)) {\r\n        throw new TypeError(\"Workflow argument expected.\");\r\n    }\r\n    if (!(_.isString(workflowVersion)) || !workflowVersion) {\r\n        throw new TypeError(\"Workflow version expected.\");\r\n    }\r\n    this.workflowVersion = workflowVersion;\r\n    this._engine = new ActivityExecutionEngine(execContext, this);\r\n    this._engine.on(\r\n        enums.events.workflowEvent,\r\n        function (args) {\r\n            let arr = _.toArray(args);\r\n            arr.splice(0, 0, self.instanceId);\r\n            self.emit(enums.events.workflowEvent, args);\r\n        });\r\n    this._addMyTrackers();\r\n    if (!_.isUndefined(instanceId)) {\r\n        this.id = instanceId;\r\n    }\r\n    this._copyParsFromHost();\r\n};\r\n\r\nWorkflowInstance.prototype.callMethod = async(function* (methodName, args) {\r\n    let self = this;\r\n\r\n    self._resetCallbacksAndState();\r\n\r\n    let endMethodReached = false;\r\n    let result = null;\r\n    self._endMethodCallback =\r\n        function (mn, ip, r) {\r\n            if (mn === methodName) {\r\n                endMethodReached = true;\r\n                result = r;\r\n            }\r\n        };\r\n\r\n    let idleMethods = [];\r\n    self._idleInstanceIdPathCallback =\r\n        function (mn, ip) {\r\n            idleMethods.push(\r\n                {\r\n                    methodName: mn,\r\n                    instanceIdPath: ip\r\n                });\r\n        };\r\n\r\n    try {\r\n        yield self._engine.resumeBookmark(specStrings.hosting.createBeginMethodBMName(methodName), enums.activityStates.complete, args);\r\n\r\n        if (!endMethodReached) {\r\n            throw new errors.WorkflowError(\"Workflow has been completed or gone to idle without reaching an EndMethod activity of method name '\" + methodName + \"'.\");\r\n        }\r\n\r\n        if (self.execState === enums.activityStates.idle) {\r\n            if (idleMethods.length === 0) {\r\n                throw new errors.WorkflowError(\"Workflow has gone to idle, but there is no active BeginMethod activities to wait for.\");\r\n            }\r\n        }\r\n        else {\r\n            if (idleMethods.length !== 0) {\r\n                throw new errors.WorkflowError(\"Workflow has completed, but there is active BeginMethod activities to wait for.\");\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n    catch (e) {\r\n        debug(\"Call method error: %s\", e.stack);\r\n        if (e instanceof errors.BookmarkNotFoundError) {\r\n            throw new errors.MethodIsNotAccessibleError(\"Cannot call method '\" + methodName + \"' of workflow '\" + self.workflowName + \"', because its bookmark doesn't exist.\");\r\n        }\r\n        throw e;\r\n    }\r\n    finally {\r\n        self._resetCallbacks();\r\n    }\r\n});\r\n\r\nWorkflowInstance.prototype._copyParsFromHost = function () {\r\n    for (let t of this._host._trackers) {\r\n        this._engine.addTracker(t);\r\n    }\r\n};\r\n\r\nWorkflowInstance.prototype._addMyTrackers = function () {\r\n    this._addBeginMethodWithCreateInstHelperTracker();\r\n    this._addEndMethodHelperTracker();\r\n    this._addIdleInstanceIdPathTracker();\r\n};\r\n\r\nWorkflowInstance.prototype._resetCallbacks = function () {\r\n    this._beginMethodWithCreateInstCallback = null;\r\n    this._endMethodCallback = null;\r\n    this._idleInstanceIdPathCallback = null;\r\n};\r\n\r\nWorkflowInstance.prototype._resetCallbacksAndState = function () {\r\n    this._resetCallbacks();\r\n    this.activeDelays = [];\r\n};\r\n\r\nWorkflowInstance.prototype._addBeginMethodWithCreateInstHelperTracker = function () {\r\n    let self = this;\r\n    let tracker = {\r\n        activityStateFilter: function (args) {\r\n            return self._beginMethodWithCreateInstCallback &&\r\n                args.scope.$activity instanceof BeginMethod &&\r\n                args.scope.canCreateInstance &&\r\n                _.isString(args.scope.methodName) &&\r\n                (!args.scope.instanceIdPath || _.isString(args.scope.instanceIdPath)) &&\r\n                args.reason === enums.activityStates.idle;\r\n        },\r\n        activityStateChanged: function (args) {\r\n            let methodName = args.scope.methodName.trim();\r\n            let instanceIdPath = args.scope.instanceIdPath ? args.scope.instanceIdPath.trim() : null;\r\n            self._beginMethodWithCreateInstCallback(methodName, instanceIdPath);\r\n        }\r\n    };\r\n    self._engine.addTracker(tracker);\r\n};\r\n\r\nWorkflowInstance.prototype._addEndMethodHelperTracker = function () {\r\n    let self = this;\r\n    let tracker = {\r\n        activityStateFilter: function (args) {\r\n            return self._endMethodCallback &&\r\n                args.scope.$activity instanceof EndMethod &&\r\n                _.isString(args.scope.methodName) &&\r\n                (!args.scope.instanceIdPath || _.isString(args.scope.instanceIdPath)) &&\r\n                args.reason === enums.activityStates.complete;\r\n        },\r\n        activityStateChanged: function (args) {\r\n            let methodName = args.scope.methodName.trim();\r\n            let instanceIdPath = args.scope.instanceIdPath ? args.scope.instanceIdPath.trim() : null;\r\n            self._endMethodCallback(methodName, instanceIdPath, args.result);\r\n        }\r\n    };\r\n    self._engine.addTracker(tracker);\r\n};\r\n\r\nWorkflowInstance.prototype._addIdleInstanceIdPathTracker = function () {\r\n    let self = this;\r\n    let tracker = {\r\n        activityStateFilter: function (args) {\r\n            return self._idleInstanceIdPathCallback &&\r\n                args.scope.$activity instanceof BeginMethod &&\r\n                _.isString(args.scope.methodName) &&\r\n                _.isString(args.scope.instanceIdPath) &&\r\n                args.reason === enums.activityStates.idle;\r\n        },\r\n        activityStateChanged: function (args) {\r\n            let methodName = args.scope.methodName.trim();\r\n            let instanceIdPath = args.scope.instanceIdPath.trim();\r\n            self._idleInstanceIdPathCallback(methodName, instanceIdPath);\r\n\r\n            // This is where a method goes idle.\r\n            // So if it a DelayTo method, we should remember that.\r\n            if (specStrings.hosting.isDelayToMethodName(methodName)) {\r\n                self.activeDelays.push({\r\n                    methodName: methodName,\r\n                    delayTo: args.scope.delayTo\r\n                });\r\n            }\r\n        }\r\n    };\r\n    self._engine.addTracker(tracker);\r\n};\r\n\r\nWorkflowInstance.prototype.getStateToPersist = function () {\r\n    let sp = this._engine.getStateAndPromotions(this._host.options.serializer, this._host.options.enablePromotions);\r\n    return {\r\n        instanceId: this.id,\r\n        createdOn: this.createdOn,\r\n        workflowName: this.workflowName,\r\n        workflowVersion: this.workflowVersion,\r\n        updatedOn: this._engine.updatedOn,\r\n        state: sp.state,\r\n        promotedProperties: sp.promotedProperties,\r\n        activeDelays: this.activeDelays\r\n    };\r\n};\r\n\r\nWorkflowInstance.prototype.restoreState = function (json) {\r\n    if (!_.isObject(json)) {\r\n        throw new TypeError(\"Argument 'json' is not an object.\");\r\n    }\r\n    if (json.instanceId !== this.id) {\r\n        throw new Error(\"State instanceId property value of '\" + json.instanceId + \"' is different than the current instance id '\" + this.id + \"'.\");\r\n    }\r\n    if (json.workflowName !== this.workflowName) {\r\n        throw new Error(\"State workflowName property value of '\" + json.workflowName + \"' is different than the current Workflow name '\" + this.workflowName + \"'.\");\r\n    }\r\n    if (json.workflowVersion !== this.workflowVersion) {\r\n        throw new Error(\"State workflowVersion property value of '\" + json.workflowVersion + \"' is different than the current Workflow version '\" + this.workflowVersion + \"'.\");\r\n    }\r\n    if (!_.isDate(json.createdOn)) {\r\n        throw new Error(\"State createdOn property value of '\" + json.createdOn + \"' is not a Date.\");\r\n    }\r\n\r\n    this.createdOn = json.createdOn;\r\n    this._engine.setState(this._host.options.serializer, json.state);\r\n};\r\n\r\nWorkflowInstance.prototype.addTracker = function(tracker) {\r\n    this._engine.addTracker(tracker);\r\n};\r\n\r\nmodule.exports = WorkflowInstance;\r\n"],"file":"hosting/workflowInstance.js","sourceRoot":"/source/"}