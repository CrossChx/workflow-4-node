{"version":3,"names":[],"mappings":"","sources":["hosting/memoryPersistence.js"],"sourcesContent":["\"use strict\";\r\n\r\nlet uuid = require('node-uuid');\r\nrequire('date-utils');\r\nlet specStrings = require(\"../common/specStrings\");\r\nlet InstIdPaths = require(\"./instIdPaths\");\r\nlet is = require(\"../common/is\");\r\nlet _ = require(\"lodash\");\r\nlet debug = require(\"debug\")(\"wf4node:MemoryPersistence\");\r\nlet errors = require(\"../common/errors\");\r\n\r\nfunction MemoryPersistence() {\r\n    this._instanceData = new Map();\r\n    this._locksById = new Map();\r\n    this._locksByName = new Map();\r\n}\r\n\r\nMemoryPersistence.prototype.clear = function () {\r\n    this._instanceData.clear();\r\n    this._locksById.clear();\r\n    this._locksByName.clear();\r\n};\r\n\r\nMemoryPersistence.prototype.enterLock = function (lockName, inLockTimeoutMs) {\r\n    debug(\"enterLock(%s, %d)\", lockName, inLockTimeoutMs);\r\n\r\n    let now = new Date();\r\n    debug(\"Searching for lock by name %s\", lockName);\r\n    let cLock = this._locksByName.get(lockName);\r\n    debug(\"Lock info: %j\", cLock);\r\n    if (!cLock || cLock.heldTo.getTime() < now.getTime()) {\r\n        let lockInfo = {\r\n            id: uuid.v4(),\r\n            name: lockName,\r\n            heldTo: now.addMilliseconds(inLockTimeoutMs)\r\n        };\r\n\r\n        this._locksById.set(lockInfo.id, lockInfo);\r\n        this._locksByName.set(lockInfo.name, lockInfo);\r\n\r\n        debug(\"LOCKED: %s\", lockInfo.name);\r\n\r\n        return lockInfo;\r\n    }\r\n    debug(\"It is already held.\");\r\n    return null;\r\n};\r\n\r\nMemoryPersistence.prototype.renewLock = function (lockId, inLockTimeoutMs) {\r\n    debug(\"renewLock(%s, %d)\", lockId, inLockTimeoutMs);\r\n\r\n    let cLock = this._getLockById(lockId);\r\n    cLock.heldTo = new Date().addMilliseconds(inLockTimeoutMs);\r\n    debug(\"Lock %s extended to %s\", lockId, cLock.heldTo);\r\n};\r\n\r\nMemoryPersistence.prototype.exitLock = function (lockId) {\r\n    debug(\"exitLock(%s)\", lockId);\r\n\r\n    let cLock = this._getLockById(lockId);\r\n    this._locksById.delete(cLock.id);\r\n    this._locksByName.delete(cLock.name);\r\n\r\n    debug(\"UNLOCKED: %s\", cLock.name);\r\n};\r\n\r\nMemoryPersistence.prototype._getLockById = function (lockId) {\r\n    let cLock = this._locksById.get(lockId);\r\n    let now = new Date();\r\n    if (!cLock || now.compareTo(cLock.heldTo) > 0) {\r\n        throw new Error(\"Lock by id '\" + lockId + \"' doesn't exists.\");\r\n    }\r\n    return cLock;\r\n};\r\n\r\nMemoryPersistence.prototype.isRunning = function (workflowName, instanceId) {\r\n    debug(\"isRunning(%s, %s)\", workflowName, instanceId);\r\n\r\n    return this._instanceData.has(specStrings.hosting.doubleKeys(workflowName, instanceId));\r\n};\r\n\r\nMemoryPersistence.prototype.persistState = function (state) {\r\n    debug(\"persistState(%j)\", state);\r\n\r\n    state = _.clone(state);\r\n    state.state = JSON.stringify(state.state);\r\n\r\n    this._instanceData.set(specStrings.hosting.doubleKeys(state.workflowName, state.instanceId), state);\r\n};\r\n\r\nMemoryPersistence.prototype.getRunningInstanceIdHeader = function (workflowName, instanceId) {\r\n    debug(\"getRunningInstanceIdHeader(%s, %s)\", workflowName, instanceId);\r\n\r\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\r\n    if (!state) {\r\n        return null;\r\n    }\r\n    return {\r\n        updatedOn: state.updatedOn,\r\n        workflowName: state.workflowName,\r\n        workflowVersion: state.workflowVersion,\r\n        instanceId: state.instanceId\r\n    };\r\n};\r\n\r\nMemoryPersistence.prototype.loadState = function (workflowName, instanceId) {\r\n    debug(\"loadState(%s, %s)\", workflowName, instanceId);\r\n\r\n    let state = this._loadState(workflowName, instanceId);\r\n    state = _.clone(state);\r\n    state.state = JSON.parse(state.state);\r\n    return state;\r\n};\r\n\r\nMemoryPersistence.prototype.removeState = function (workflowName, instanceId) {\r\n    debug(\"removeState(%s, %s)\", workflowName, instanceId);\r\n\r\n    this._instanceData.delete(specStrings.hosting.doubleKeys(workflowName, instanceId));\r\n};\r\n\r\nMemoryPersistence.prototype._loadState = function (workflowName, instanceId) {\r\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\r\n    if (!state) {\r\n        throw new errors.WorkflowNotFoundError(\"Instance data of workflow '\" + workflowName + \"' by id '\" + instanceId + \"' is not found.\");\r\n    }\r\n    return state;\r\n};\r\n\r\nMemoryPersistence.prototype.loadPromotedProperties = function (workflowName, instanceId) {\r\n    debug(\"loadPromotedProperties(%s, %s)\", workflowName, instanceId);\r\n\r\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\r\n    return state ? state.promotedProperties : null;\r\n};\r\n\r\nMemoryPersistence.prototype.getNextWakeupables = function (count) {\r\n    debug(\"getNextWakeupables(%d)\", count);\r\n\r\n    let now = new Date();\r\n    let result = [];\r\n    for (let data of this._instanceData.values()) {\r\n        if (data.activeDelays) {\r\n            for (let ad of data.activeDelays) {\r\n                if (ad.delayTo <= now) {\r\n                    result.push({\r\n                        instanceId: data.instanceId,\r\n                        workflowName: data.workflowName,\r\n                        updatedOn: data.updatedOn,\r\n                        activeDelay: {\r\n                            methodName: ad.methodName,\r\n                            delayTo: ad.delayTo\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    result.sort(function (i1, i2) {\r\n        if (i1.updatedOn < i2.updatedOn) {\r\n            return -1;\r\n        }\r\n        else if (i1.updatedOn > i2.updatedOn) {\r\n            return 1;\r\n        }\r\n        else if (i1.activeDelay.delayTo < i2.activeDelay.delayTo) {\r\n            return -1;\r\n        }\r\n        else if (i1.activeDelay.delayTo > i2.activeDelay.delayTo) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    });\r\n    return _.take(result, count);\r\n};\r\n\r\nMemoryPersistence.prototype.getRunningInstanceHeadersForOtherVersion = function (workflowName, version) {\r\n    let result = [];\r\n    for (let data of this._instanceData.values()) {\r\n        if (data.workflowName === workflowName && data.version !== version) {\r\n            result.push({\r\n                workflowName: data.workflowName,\r\n                workflowVersion: data.workflowVersion,\r\n                instanceId: data.instanceId\r\n            });\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\nmodule.exports = MemoryPersistence;"],"file":"hosting/memoryPersistence.js","sourceRoot":"/source/"}