{"version":3,"names":[],"mappings":"","sources":["hosting/memoryPersistence.js"],"sourcesContent":["\"use strict\";\n\nlet uuid = require('node-uuid');\nrequire('date-utils');\nlet specStrings = require(\"../common/specStrings\");\nlet InstIdPaths = require(\"./instIdPaths\");\nlet is = require(\"../common/is\");\nlet _ = require(\"lodash\");\nlet debug = require(\"debug\")(\"wf4node:MemoryPersistence\");\nlet errors = require(\"../common/errors\");\n\nfunction MemoryPersistence() {\n    this._instanceData = new Map();\n    this._locksById = new Map();\n    this._locksByName = new Map();\n}\n\nMemoryPersistence.prototype.clear = function () {\n    this._instanceData.clear();\n    this._locksById.clear();\n    this._locksByName.clear();\n};\n\nMemoryPersistence.prototype.enterLock = function (lockName, inLockTimeoutMs) {\n    debug(\"enterLock(%s, %d)\", lockName, inLockTimeoutMs);\n\n    let now = new Date();\n    debug(\"Searching for lock by name %s\", lockName);\n    let cLock = this._locksByName.get(lockName);\n    debug(\"Lock info: %j\", cLock);\n    if (!cLock || cLock.heldTo.getTime() < now.getTime()) {\n        let lockInfo = {\n            id: uuid.v4(),\n            name: lockName,\n            heldTo: now.addMilliseconds(inLockTimeoutMs)\n        };\n\n        this._locksById.set(lockInfo.id, lockInfo);\n        this._locksByName.set(lockInfo.name, lockInfo);\n\n        debug(\"LOCKED: %s\", lockInfo.name);\n\n        return lockInfo;\n    }\n    debug(\"It is already held.\");\n    return null;\n};\n\nMemoryPersistence.prototype.renewLock = function (lockId, inLockTimeoutMs) {\n    debug(\"renewLock(%s, %d)\", lockId, inLockTimeoutMs);\n\n    let cLock = this._getLockById(lockId);\n    cLock.heldTo = new Date().addMilliseconds(inLockTimeoutMs);\n    debug(\"Lock %s extended to %s\", lockId, cLock.heldTo);\n};\n\nMemoryPersistence.prototype.exitLock = function (lockId) {\n    debug(\"exitLock(%s)\", lockId);\n\n    let cLock = this._getLockById(lockId);\n    this._locksById.delete(cLock.id);\n    this._locksByName.delete(cLock.name);\n\n    debug(\"UNLOCKED: %s\", cLock.name);\n};\n\nMemoryPersistence.prototype._getLockById = function (lockId) {\n    let cLock = this._locksById.get(lockId);\n    let now = new Date();\n    if (!cLock || now.compareTo(cLock.heldTo) > 0) {\n        throw new Error(\"Lock by id '\" + lockId + \"' doesn't exists.\");\n    }\n    return cLock;\n};\n\nMemoryPersistence.prototype.isRunning = function (workflowName, instanceId) {\n    debug(\"isRunning(%s, %s)\", workflowName, instanceId);\n\n    return this._instanceData.has(specStrings.hosting.doubleKeys(workflowName, instanceId));\n};\n\nMemoryPersistence.prototype.persistState = function (state) {\n    debug(\"persistState(%j)\", state);\n\n    state = _.clone(state);\n    state.state = JSON.stringify(state.state);\n\n    this._instanceData.set(specStrings.hosting.doubleKeys(state.workflowName, state.instanceId), state);\n};\n\nMemoryPersistence.prototype.getRunningInstanceIdHeader = function (workflowName, instanceId) {\n    debug(\"getRunningInstanceIdHeader(%s, %s)\", workflowName, instanceId);\n\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\n    if (!state) {\n        return null;\n    }\n    return {\n        updatedOn: state.updatedOn,\n        workflowName: state.workflowName,\n        workflowVersion: state.workflowVersion,\n        instanceId: state.instanceId\n    };\n};\n\nMemoryPersistence.prototype.loadState = function (workflowName, instanceId) {\n    debug(\"loadState(%s, %s)\", workflowName, instanceId);\n\n    let state = this._loadState(workflowName, instanceId);\n    state = _.clone(state);\n    state.state = JSON.parse(state.state);\n    return state;\n};\n\nMemoryPersistence.prototype.removeState = function (workflowName, instanceId) {\n    debug(\"removeState(%s, %s)\", workflowName, instanceId);\n\n    this._instanceData.delete(specStrings.hosting.doubleKeys(workflowName, instanceId));\n};\n\nMemoryPersistence.prototype._loadState = function (workflowName, instanceId) {\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\n    if (!state) {\n        throw new errors.WorkflowNotFoundError(\"Instance data of workflow '\" + workflowName + \"' by id '\" + instanceId + \"' is not found.\");\n    }\n    return state;\n};\n\nMemoryPersistence.prototype.loadPromotedProperties = function (workflowName, instanceId) {\n    debug(\"loadPromotedProperties(%s, %s)\", workflowName, instanceId);\n\n    let state = this._instanceData.get(specStrings.hosting.doubleKeys(workflowName, instanceId));\n    return state ? state.promotedProperties : null;\n};\n\nMemoryPersistence.prototype.getNextWakeupables = function (count) {\n    debug(\"getNextWakeupables(%d)\", count);\n\n    let now = new Date();\n    let result = [];\n    for (let data of this._instanceData.values()) {\n        if (data.activeDelays) {\n            for (let ad of data.activeDelays) {\n                if (ad.delayTo <= now) {\n                    result.push({\n                        instanceId: data.instanceId,\n                        workflowName: data.workflowName,\n                        updatedOn: data.updatedOn,\n                        activeDelay: {\n                            methodName: ad.methodName,\n                            delayTo: ad.delayTo\n                        }\n                    });\n                }\n            }\n        }\n    }\n    result.sort(function (i1, i2) {\n        if (i1.updatedOn < i2.updatedOn) {\n            return -1;\n        }\n        else if (i1.updatedOn > i2.updatedOn) {\n            return 1;\n        }\n        else if (i1.activeDelay.delayTo < i2.activeDelay.delayTo) {\n            return -1;\n        }\n        else if (i1.activeDelay.delayTo > i2.activeDelay.delayTo) {\n            return 1;\n        }\n        return 0;\n    });\n    return _.take(result, count);\n};\n\nMemoryPersistence.prototype.getRunningInstanceHeadersForOtherVersion = function (workflowName, version) {\n    let result = [];\n    for (let data of this._instanceData.values()) {\n        if (data.workflowName === workflowName && data.version !== version) {\n            result.push({\n                workflowName: data.workflowName,\n                workflowVersion: data.workflowVersion,\n                instanceId: data.instanceId\n            });\n        }\n    }\n    return result;\n};\n\nmodule.exports = MemoryPersistence;"],"file":"hosting/memoryPersistence.js","sourceRoot":"/source/"}